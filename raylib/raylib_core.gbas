// --------------------------------- //
// Project: RayLib
// Start: Sunday, May 03, 2020
// IDE Version: 16.508


INLINE
}
#include <stdlib.h> // malloc, free, rand

namespace LIB{
	#include "raylib.h"
}

	RL_Vector2 RaylibVector2_to_GLBasicVector2(LIB::Vector2 *v2)
	{
		RL_Vector2 vec2;
		vec2.x = v2->x;
		vec2.y = v2->y;
		return vec2;
	}

	LIB::Vector2 GLBasicVector2_to_RaylibVector2(RL_Vector2 v2)
	{
		LIB::Vector2 vec2;
		vec2.x = v2.x;
		vec2.y = v2.y;
		return vec2;
	}

	RL_Color RaylibColor_to_GLBasicColor(LIB::Color *c)
	{
		RL_Color col;
		col.r = c->r;
		col.g = c->g;
		col.b = c->b;
		col.a = c->a;

		return col;
	}

	LIB::Color GLBasicColor_to_RaylibColor(RL_Color c)
	{
		LIB::Color col;
		col.r = c.r;
		col.g = c.g;
		col.b = c.b;
		col.a = c.a;

		return col;
	}

	RL_Font RaylibFont_to_GLBasicFont(LIB::Font *f)
	{
		RL_Font fnt;
		fnt.baseSize 		= f->baseSize;
		fnt.charsCount 		= f->charsCount;
		fnt.texture.id 		= f->texture.id;
		fnt.texture.width 	= f->texture.width;
		fnt.texture.height	= f->texture.height;
		fnt.texture.mipmaps = f->texture.mipmaps;
		fnt.texture.format	= f->texture.format;

		for(int i = 0; i < f->charsCount; i++)
		{
			RL_Rectangle r;
			r.x 		= f->recs[i].x;
			r.y 		= f->recs[i].y;
			r.width 	= f->recs[i].width;
			r.height 	= f->recs[i].height;
			DIMPUSH(fnt.recs, r);


			RL_CharInfo c;
			c.value =  f->chars[i].value;
			c.offsetX = f->chars[i].offsetX;
			c.offsetY = f->chars[i].offsetY;
			c.advanceX = f->chars[i].advanceX;

			c._image.data_Str = (const char*)f->chars[i].image.data;
			c._image.width = f->chars[i].image.width;
			c._image.height = f->chars[i].image.height;
			c._image.mipmaps = f->chars[i].image.mipmaps;
			c._image.format = f->chars[i].image.format;
			DIMPUSH(fnt.chars, c);
		}
		return fnt;
	}


	LIB::Font GLBasicFont_to_RaylibFont(RL_Font f)
	{
		LIB::Font fnt;

		fnt.baseSize 		= f.baseSize;
		fnt.charsCount 		= f.charsCount;
		fnt.texture.id 		= f.texture.id;
		fnt.texture.width 	= f.texture.width;
		fnt.texture.height	= f.texture.height;
		fnt.texture.mipmaps = f.texture.mipmaps;
		fnt.texture.format	= f.texture.format;

		fnt.chars = (LIB::CharInfo *)malloc(fnt.charsCount*sizeof(LIB::CharInfo));
		fnt.recs = (LIB::Rectangle *)malloc(fnt.charsCount*sizeof(LIB::Rectangle));

		for(int i = 0; i < f.charsCount; i++)
		{
			// recs
			fnt.recs[i].x 		= f.recs(i).x;
			fnt.recs[i].y 		= f.recs(i).y;
			fnt.recs[i].width 	= f.recs(i).width;
			fnt.recs[i].height 	= f.recs(i).height;

			// chars
			fnt.chars[i].value = f.chars(i).value;
			fnt.chars[i].offsetX = f.chars(i).offsetX;
			fnt.chars[i].offsetY = f.chars(i).offsetY;
			fnt.chars[i].advanceX = f.chars(i).advanceX;

			//image
			fnt.chars[i].image.data = (void*)f.chars(i)._image.data_Str;
			fnt.chars[i].image.width = f.chars(i)._image.width;
			fnt.chars[i].image.height = f.chars(i)._image.height;
			fnt.chars[i].image.mipmaps = f.chars(i)._image.mipmaps;
			fnt.chars[i].image.format = f.chars(i)._image.format;
		}
		
		free(fnt.chars);
		free(fnt.recs);
		
		return fnt;
	}


	RL_Image RaylibImage_to_GLBasicImage(LIB::Image *i)
	{
		RL_Image img;

		img.data_Str 	= (const char*)i->data;
		img.width 		= i->width;
		img.height 		= i->height;
		img.mipmaps 	= i->mipmaps;
		img.format		= i->format;

		return img;
	}

	LIB::Image GLBasicImage_to_RaylibImage(RL_Image i)
	{
		LIB::Image img;

		img.data 		= (void*)i.data_Str;
		img.width 		= i.width;
		img.height 		= i.height;
		img.mipmaps 	= i.mipmaps;
		img.format		= i.format;

		return img;
	}


	RL_Texture2D RaylibTexture2D_to_GLBasicTexture2D(LIB::Texture2D *t)
	{
		RL_Texture2D tex;

		tex.id 			= t->id;
		tex.width 		= t->width;
		tex.height 		= t->height;
		tex.mipmaps 	= t->mipmaps;
		tex.format		= t->format;

		return tex;
	}

	LIB::Texture2D GLBasicTexture2D_to_RaylibTexture2D(RL_Texture2D t)
	{
		LIB::Texture2D tex;

		tex.id 			= t.id;
		tex.width 		= t.width;
		tex.height 		= t.height;
		tex.mipmaps 	= t.mipmaps;
		tex.format		= t.format;

		return tex;
	}

namespace __GLBASIC__{
ENDINLINE

SUB _RAYLIB_CORE:
	// JUST FOR QUICKJUMPING IN SOURCE!
ENDSUB

//------------------------------
// Window-related functions
//------------------------------
FUNCTION RL_InitWindow: width, height, title$  // Initialize window and OpenGL context

INLINE
	LIB::InitWindow(width, height, title_Str.c_str());
ENDINLINE
ENDFUNCTION

FUNCTION RL_WindowShouldClose: // Check if KEY_ESCAPE pressed or Close icon pressed
INLINE
	return LIB::WindowShouldClose();
ENDINLINE
ENDFUNCTION

FUNCTION RL_CloseWindow:  // Close window and unload OpenGL context
INLINE
	LIB::CloseWindow();
ENDINLINE
ENDFUNCTION

FUNCTION RL_IsWindowReady:  // Check if window has been initialized successfully
INLINE
	return LIB::IsWindowReady();
ENDINLINE
ENDFUNCTION

FUNCTION RL_IsWindowMinimized:  // Check if window has been minimized
INLINE
	return LIB::IsWindowMinimized();
ENDINLINE
ENDFUNCTION

FUNCTION RL_IsWindowResized:  // Check if window has been resized
INLINE
	return LIB::IsWindowResized();
ENDINLINE
ENDFUNCTION

FUNCTION RL_IsWindowHidden:  // Check if window is currently hidden
INLINE
	return LIB::IsWindowHidden();
ENDINLINE
ENDFUNCTION

FUNCTION RL_IsWindowFullscreen:  // Check if window is currently fullscreen
INLINE
	return LIB::IsWindowFullscreen();
ENDINLINE
ENDFUNCTION

FUNCTION RL_ToggleFullscreen:  // Toggle fullscreen mode
INLINE
	LIB::ToggleFullscreen();
ENDINLINE
ENDFUNCTION

FUNCTION RL_UnhideWindow:  // Show the window
INLINE
	LIB::UnhideWindow();
ENDINLINE
ENDFUNCTION

FUNCTION RL_HideWindow:  // Hide the window
INLINE
	LIB::HideWindow();
ENDINLINE
ENDFUNCTION

//FUNCTION RL_SetWindowIcon: Image image  // Set icon for window
//INLINE
//	LIB::SetWindowIcon(Image image);
//ENDINLINE
//ENDFUNCTION

FUNCTION RL_SetWindowTitle: title$  // Set title for window
INLINE
	LIB::SetWindowTitle(title_Str.c_str());
ENDINLINE
ENDFUNCTION

FUNCTION RL_SetWindowPosition: x, y  // Set window position on screen
INLINE
	LIB::SetWindowPosition(x, y);
ENDINLINE
ENDFUNCTION

FUNCTION RL_SetWindowMonitor: monitor  // Set monitor for the current window
INLINE
	LIB::SetWindowMonitor(monitor);
ENDINLINE
ENDFUNCTION

FUNCTION RL_SetWindowMinSize: width, height  // Set window minimum dimensions
INLINE
	LIB::SetWindowMinSize(width, height);
ENDINLINE
ENDFUNCTION

FUNCTION RL_SetWindowSize: width, height  // Set window dimensions
INLINE
	LIB::SetWindowSize(width, height);
ENDINLINE
ENDFUNCTION

FUNCTION RL_GetWindowHandle:   // Get native window handle
INLINE
	return (long)LIB::GetWindowHandle();
ENDINLINE
ENDFUNCTION

FUNCTION RL_GetScreenWidth:  // Get current screen width
INLINE
	return LIB::GetScreenWidth();
ENDINLINE
ENDFUNCTION

FUNCTION RL_GetScreenHeight:  // Get current screen height
INLINE
	return LIB::GetScreenHeight();
ENDINLINE
ENDFUNCTION

FUNCTION RL_GetMonitorCount:  // Get number of connected monitors
INLINE
	return LIB::GetMonitorCount();
ENDINLINE
ENDFUNCTION

FUNCTION RL_GetMonitorWidth: monitor  // Get primary monitor width
INLINE
	return LIB::GetMonitorWidth(monitor);
ENDINLINE
ENDFUNCTION

FUNCTION RL_GetMonitorHeight: monitor  // Get primary monitor height
INLINE
	return LIB::GetMonitorHeight(monitor);
ENDINLINE
ENDFUNCTION

FUNCTION RL_GetMonitorPhysicalWidth: monitor  // Get primary monitor physical width in millimetres
INLINE
	return LIB::GetMonitorPhysicalWidth(monitor);
ENDINLINE
ENDFUNCTION

FUNCTION RL_GetMonitorPhysicalHeight: monitor  // Get primary monitor physical height in millimetres
INLINE
	return LIB::GetMonitorPhysicalHeight(monitor);
ENDINLINE
ENDFUNCTION

FUNCTION RL_GetWindowPosition AS RL_Vector2:  // Get window position XY on monitor
INLINE
	LIB::Vector2 v;
	v = LIB::GetWindowPosition();
	return RaylibVector2_to_GLBasicVector2(&v);
ENDINLINE
ENDFUNCTION

FUNCTION RL_GetMonitorName$:monitor  // Get the human-readable, UTF-8 encoded name of the primary monitor
INLINE
	return LIB::GetMonitorName(monitor);
ENDINLINE
ENDFUNCTION

FUNCTION RL_GetClipboardText$:  // Get clipboard text content
INLINE
	return LIB::GetClipboardText();
ENDINLINE
ENDFUNCTION

FUNCTION RL_SetClipboardText: text$  // Set clipboard text content
INLINE
	LIB::SetClipboardText(text_Str.c_str());
ENDINLINE
ENDFUNCTION

//------------------------------
// Cursor-related functions
//------------------------------
FUNCTION RL_ShowCursor:  // Shows cursor
INLINE
	LIB::ShowCursor();
ENDINLINE
ENDFUNCTION

FUNCTION RL_HideCursor:  // Hides cursor
INLINE
	LIB::HideCursor();
ENDINLINE
ENDFUNCTION

FUNCTION RL_IsCursorHidden:  // Check if cursor is not visible
INLINE
	return LIB::IsCursorHidden();
ENDINLINE
ENDFUNCTION

FUNCTION RL_EnableCursor:  // Enables cursor
INLINE
	LIB::EnableCursor();
ENDINLINE
ENDFUNCTION

FUNCTION RL_DisableCursor:  // Disables cursor
INLINE
	LIB::DisableCursor();
ENDINLINE
ENDFUNCTION

//------------------------------
// Drawing-related functions
//------------------------------
FUNCTION RL_ClearBackground: _color AS RL_Color  // Set background color
INLINE
	LIB::ClearBackground( GLBasicColor_to_RaylibColor(_color) );
ENDINLINE
ENDFUNCTION

FUNCTION RL_BeginDrawing:  // Setup canvas
INLINE
	LIB::BeginDrawing();
ENDINLINE
ENDFUNCTION

FUNCTION RL_EndDrawing:  // End canvas drawing and swap buffers
INLINE
	LIB::EndDrawing();
ENDINLINE
ENDFUNCTION

//FUNCTION RL_BeginMode2D: Camera2D camera  // Initialize 2D mode with custom camera
//INLINE
//	LIB::BeginMode2D(Camera2D camera);
//ENDINLINE
//ENDFUNCTION

FUNCTION RL_EndMode2D:  // Ends 2D mode with custom camera
INLINE
	LIB::EndMode2D();
ENDINLINE
ENDFUNCTION

//FUNCTION RL_BeginMode3D: Camera3D camera  // Initializes 3D mode with custom camera
//INLINE
//	LIB::BeginMode3D(Camera3D camera);
//ENDINLINE
//ENDFUNCTION

FUNCTION RL_EndMode3D:  // Ends 3D mode and returns to default 2D orthographic mode
INLINE
	LIB::EndMode3D();
ENDINLINE
ENDFUNCTION

//FUNCTION BeginTextureMode: RenderTexture2D target  // Initializes render texture for drawing
//INLINE
//	LIB::BeginTextureMode(RenderTexture2D target);
//ENDINLINE
//ENDFUNCTION

FUNCTION RL_EndTextureMode:  // Ends drawing to render texture
INLINE
	LIB::EndTextureMode();
ENDINLINE
ENDFUNCTION

FUNCTION RL_BeginScissorMode: x, y, width, height  // Begin scissor mode
INLINE
	LIB::BeginScissorMode(x, y, width, height);
ENDINLINE
ENDFUNCTION

FUNCTION RL_EndScissorMode:  // End scissor mode
INLINE
	LIB::EndScissorMode();
ENDINLINE
ENDFUNCTION

////------------------------------
//// Screen-space-related functions
////------------------------------
//FUNCTION RL_GetMouseRay: Vector2 mousePosition, Camera camera  // Returns a ray trace from mouse position
//INLINE
//	return LIB::GetMouseRay(Vector2 mousePosition, Camera camera);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION RL_GetCameraMatrix: Camera camera  // Returns camera transform matrix
//INLINE
//	return LIB::GetCameraMatrix(Camera camera);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION RL_GetCameraMatrix2D: Camera2D camera  // Returns camera 2d transform matrix
//INLINE
//	return LIB::GetCameraMatrix2D(Camera2D camera);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION RL_GetWorldToScreen: Vector3 position, Camera camera  // Returns the screen space position for a 3d world space position
//INLINE
//	return LIB::GetWorldToScreen(Vector3 position, Camera camera);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION RL_GetWorldToScreenEx: Vector3 position, Camera camera,int width, int height  // Returns size position for a 3d world space position
//INLINE
//	return LIB::GetWorldToScreenEx(Vector3 position, Camera camera,int width, int height);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION RL_GetWorldToScreen2D: Vector2 position, Camera2D camera  // Returns the screen space position for a 2d camera world space position
//INLINE
//	return LIB::GetWorldToScreen2D(Vector2 position, Camera2D camera);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION RL_GetScreenToWorld2D: Vector2 position, Camera2D camera  // Returns the world space position for a 2d camera screen space position
//INLINE
//	return LIB::GetScreenToWorld2D(Vector2 position, Camera2D camera);
//ENDINLINE
//ENDFUNCTION
//
////------------------------------
//// Timing-related functions
////------------------------------
FUNCTION RL_SetTargetFPS: fps  // Set target FPS
INLINE
	LIB::SetTargetFPS(fps);
ENDINLINE
ENDFUNCTION

FUNCTION RL_GetFPS:  // Returns current FPS
INLINE
	return LIB::GetFPS();
ENDINLINE
ENDFUNCTION

FUNCTION RL_GetFrameTime:  // Returns time in seconds for last frame drawn
INLINE
	return LIB::GetFrameTime();
ENDINLINE
ENDFUNCTION

FUNCTION RL_GetTime:  // Returns elapsed time in seconds since InitWindow
INLINE
	return LIB::GetTime();
ENDINLINE
ENDFUNCTION

////------------------------------
//// Color-related functions
////------------------------------
FUNCTION RL_ColorToInt: r, g, b, a  // Returns hexadecimal value for a Color
INLINE
	return LIB::ColorToInt({r, g, b, a});
ENDINLINE
ENDFUNCTION

//FUNCTION RL_ColorNormalize: Color color  // Returns color normalized as float [0..1]
//INLINE
//	return LIB::ColorNormalize(Color color);
//ENDINLINE
//ENDFUNCTION

//FUNCTION RL_ColorFromNormalized: Vector4 normalized  // Returns color from normalized values [0..1]
//INLINE
//	return LIB::ColorFromNormalized(Vector4 normalized);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION RL_ColorToHSV: Color color  // Returns HSV values for a Color
//INLINE
//	return LIB::ColorToHSV(Color color);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION RL_ColorFromHSV: Vector3 hsv  // Returns a Color from HSV values
//INLINE
//	return LIB::ColorFromHSV(Vector3 hsv);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION RL_GetColor: int hexValue  // Returns a Color struct from hexadecimal value
//INLINE
//	return LIB::GetColor(int hexValue);
//ENDINLINE
//ENDFUNCTION
//
FUNCTION RL_Fade: _color AS RL_Color, alpha#  // Color fade-in or fade-out, alpha goes from 0.0f to 1.0f
INLINE
	LIB::Color c;
	c = GLBasicColor_to_RaylibColor(_color);

	c =  LIB::Fade(c, (float)alpha);

	_color = RaylibColor_to_GLBasicColor(&c);
ENDINLINE
ENDFUNCTION

////------------------------------
//// Misc. functions
////------------------------------
FUNCTION RL_SetConfigFlags: flags  // Setup window configuration flags
INLINE
	LIB::SetConfigFlags(flags);
ENDINLINE
ENDFUNCTION

FUNCTION RL_SetTraceLogLevel: logType  // Set the current threshold
INLINE
	LIB::SetTraceLogLevel(logType);
ENDINLINE
ENDFUNCTION

FUNCTION RL_SetTraceLogExit: logType  // Set the exit threshold
INLINE
	LIB::SetTraceLogExit(logType);
ENDINLINE
ENDFUNCTION

//FUNCTION RL_SetTraceLogCallback: TraceLogCallback CALLBACK  // Set a trace log callback to enable custom logging
//INLINE
//	LIB::SetTraceLogCallback(TraceLogCallback CALLBACK);
//ENDINLINE
//ENDFUNCTION

//FUNCTION RL_TraceLog: int logType, const char *text, ...  // Show trace log messages
//INLINE
//	LIB::TraceLog(int logType, const char *text, ...);
//ENDINLINE
//ENDFUNCTION

FUNCTION RL_TakeScreenshot: fileName$  // Takes a screenshot of current screen
INLINE
	LIB::TakeScreenshot(fileName_Str.c_str());
ENDINLINE
ENDFUNCTION

FUNCTION RL_GetRandomValue: valMIN, valMAX  // Returns a random value between min and max
INLINE
	return LIB::GetRandomValue(valMIN, valMAX);
ENDINLINE
ENDFUNCTION

////------------------------------
//// Files management functions
////------------------------------
FUNCTION RL_LoadFileData$: fileName$, BYREF bytesRead  // Load file data as byte array
INLINE
	unsigned int bytesread;
	unsigned char* result;
	result =  LIB::LoadFileData(fileName_Str.c_str(), &bytesread);
	bytesRead = bytesread;
	return (const char*)result;
ENDINLINE
ENDFUNCTION

FUNCTION RL_SaveFileData: fileName$, data$, bytesToWrite  // Save data to file from byte array
INLINE
	LIB::SaveFileData(fileName_Str.c_str(), (void*)data_Str.c_str(), bytesToWrite);
ENDINLINE
ENDFUNCTION

FUNCTION RL_LoadFileText$: fileName$  // Load text data from file
INLINE
	return LIB::LoadFileText(fileName_Str.c_str());
ENDINLINE
ENDFUNCTION

FUNCTION RL_SaveFileText: fileName$, text$  // Save text data to file
INLINE
	LIB::SaveFileText(fileName_Str.c_str(), (char*)text_Str.c_str());
ENDINLINE
ENDFUNCTION

FUNCTION RL_FileExists: fileName$  // Check if file exists
INLINE
	return LIB::FileExists(fileName_Str.c_str());
ENDINLINE
ENDFUNCTION

FUNCTION RL_IsFileExtension: fileName$, ext$  // Check file extension
INLINE
	return LIB::IsFileExtension(fileName_Str.c_str(), ext_Str.c_str());
ENDINLINE
ENDFUNCTION

FUNCTION RL_DirectoryExists: dirPath$  // Check if a directory path exists
INLINE
	return LIB::DirectoryExists(dirPath_Str.c_str());
ENDINLINE
ENDFUNCTION

FUNCTION RL_GetExtension$: fileName$  // Get pointer to extension for a filename string
INLINE
	return LIB::GetExtension(fileName_Str.c_str());
ENDINLINE
ENDFUNCTION

FUNCTION RL_GetFileName$: filePath$  // Get pointer to filename for a path string
INLINE
	return LIB::GetFileName(filePath_Str.c_str());
ENDINLINE
ENDFUNCTION

FUNCTION RL_GetFileNameWithoutExt$: filePath$  // Get filename string without extension
INLINE
	return LIB::GetFileNameWithoutExt(filePath_Str.c_str());
ENDINLINE
ENDFUNCTION

FUNCTION RL_GetDirectoryPath$: filePath$  // Get full path for a given fileName with path
INLINE
	return LIB::GetDirectoryPath(filePath_Str.c_str());
ENDINLINE
ENDFUNCTION

FUNCTION RL_GetPrevDirectoryPath$: dirPath$  // Get previous directory path for a given path
INLINE
	return LIB::GetPrevDirectoryPath(dirPath_Str.c_str());
ENDINLINE
ENDFUNCTION

FUNCTION RL_GetWorkingDirectory$:  // Get current working directory
INLINE
	return LIB::GetWorkingDirectory();
ENDINLINE
ENDFUNCTION

FUNCTION RL_GetDirectoryFiles: dirPath$, BYREF count, result$[]  // Get filenames in a directory path
INLINE
	int fileCount;
	char** files;

	files = LIB::GetDirectoryFiles(dirPath_Str.c_str(), &fileCount);

	DIM(result_Str, fileCount);
	for(int i = 0; i<fileCount; i++)
	{
		result_Str(i) = files[i]; // arrays in GLBasic are allways be a reference in functions!
	}
	count = fileCount;
ENDINLINE
ENDFUNCTION

FUNCTION RL_ClearDirectoryFiles:  // Clear directory files paths buffers
INLINE
	LIB::ClearDirectoryFiles();
ENDINLINE
ENDFUNCTION

FUNCTION RL_ChangeDirectory: dir$  // Change working directory, returns true if success
INLINE
	return LIB::ChangeDirectory(dir_Str.c_str());
ENDINLINE
ENDFUNCTION

FUNCTION RL_IsFileDropped:  // Check if a file has been dropped into window
INLINE
	return LIB::IsFileDropped();
ENDINLINE
ENDFUNCTION

FUNCTION RL_GetDroppedFiles: BYREF count, result$[]  // Get dropped files names
INLINE
	int fileCount;
	char** files;
	files =  LIB::GetDroppedFiles(&fileCount);

	DIM(result_Str, fileCount);
	for(int i = 0; i<fileCount; i++)
	{
		result_Str(i) = files[i]; // arrays in GLBasic are allways be a reference in functions!
	}
	count = fileCount;

ENDINLINE
ENDFUNCTION

FUNCTION RL_ClearDroppedFiles:  // Clear dropped files paths buffer
INLINE
	LIB::ClearDroppedFiles();
ENDINLINE
ENDFUNCTION

FUNCTION RL_GetFileModTime: fileName$  // Get file modification time
INLINE
	return LIB::GetFileModTime(fileName_Str.c_str());
ENDINLINE
ENDFUNCTION

FUNCTION RL_CompressData$: data$, dataLength, BYREF compDataLength  // Compress data
INLINE
	int compdatalength;
	unsigned char* result;
	result =  LIB::CompressData((unsigned char*)data_Str.c_str(), dataLength, &compdatalength);
	compDataLength = compdatalength;
	return (const char*)result;
ENDINLINE
ENDFUNCTION

FUNCTION RL_DecompressData$: compData$, compDataLength, BYREF dataLength  // Decompress data
INLINE
	int datalength;
	unsigned char* result;
	result =  LIB::DecompressData((unsigned char*)compData_Str.c_str(), compDataLength, &datalength);
	dataLength = datalength;
	return (const char*)result;
ENDINLINE
ENDFUNCTION

////------------------------------
//// Persistent storage management
////------------------------------
FUNCTION RL_LoadStorageValue: position  // Load integer value from storage file
INLINE
	return LIB::LoadStorageValue(position);
ENDINLINE
ENDFUNCTION

FUNCTION RL_SaveStorageValue: position, value  // Save integer value to storage file
INLINE
	LIB::SaveStorageValue(position, value);
ENDINLINE
ENDFUNCTION

FUNCTION RL_OpenURL: url$  // Open URL with default system browser
INLINE
	LIB::OpenURL(url_Str.c_str());
ENDINLINE
ENDFUNCTION

////------------------------------
//// Input Handling Functions
////------------------------------
////------------------------------
//// Input-related functions: keyb
////------------------------------
FUNCTION RL_IsKeyPressed: inkey  // Detect if a key has been pressed once
INLINE
	return LIB::IsKeyPressed(inkey);
ENDINLINE
ENDFUNCTION

FUNCTION RL_IsKeyDown: inkey  // Detect if a key is being pressed
INLINE
	return LIB::IsKeyDown(inkey);
ENDINLINE
ENDFUNCTION

FUNCTION RL_IsKeyReleased: inkey  // Detect if a key has been released once
INLINE
	return LIB::IsKeyReleased(inkey);
ENDINLINE
ENDFUNCTION

FUNCTION RL_IsKeyUp: inkey  // Detect if a key is NOT being pressed
INLINE
	return LIB::IsKeyUp(inkey);
ENDINLINE
ENDFUNCTION

FUNCTION RL_GetKeyPressed:   // Get latest key pressed
INLINE
	return LIB::GetKeyPressed();
ENDINLINE
ENDFUNCTION

FUNCTION RL_SetExitKey: inkey // Set a custom key to exit program
INLINE
	LIB::SetExitKey(inkey);
ENDINLINE
ENDFUNCTION

////------------------------------
//// Input-related functions: gamepads
////------------------------------
FUNCTION RL_IsGamepadAvailable: gamepad  // Detect if a gamepad is available
INLINE
	return LIB::IsGamepadAvailable(gamepad);
ENDINLINE
ENDFUNCTION

FUNCTION RL_IsGamepadName: gamepad, name$  // Check gamepad name
INLINE
	return LIB::IsGamepadName(gamepad, name_Str.c_str());
ENDINLINE
ENDFUNCTION

FUNCTION RL_GetGamepadName$: gamepad  // Return gamepad internal name id
INLINE
	return LIB::GetGamepadName(gamepad);
ENDINLINE
ENDFUNCTION

FUNCTION RL_IsGamepadButtonPressed: gamepad, button  // Detect if a gamepad button has been pressed once
INLINE
	return LIB::IsGamepadButtonPressed(gamepad, button);
ENDINLINE
ENDFUNCTION

FUNCTION RL_IsGamepadButtonDown: gamepad, button  // Detect if a gamepad button is being pressed
INLINE
	return LIB::IsGamepadButtonDown(gamepad, button);
ENDINLINE
ENDFUNCTION

FUNCTION RL_IsGamepadButtonReleased: gamepad, button  // Detect if a gamepad button has been released once
INLINE
	return LIB::IsGamepadButtonReleased(gamepad, button);
ENDINLINE
ENDFUNCTION

FUNCTION RL_IsGamepadButtonUp: gamepad, button  // Detect if a gamepad button is NOT being pressed
INLINE
	return LIB::IsGamepadButtonUp(gamepad, button);
ENDINLINE
ENDFUNCTION

FUNCTION RL_GetGamepadButtonPressed:  // Get the last gamepad button pressed
INLINE
	return LIB::GetGamepadButtonPressed();
ENDINLINE
ENDFUNCTION

FUNCTION RL_GetGamepadAxisCount: gamepad  // Return gamepad axis count for a gamepad
INLINE
	return LIB::GetGamepadAxisCount(gamepad);
ENDINLINE
ENDFUNCTION

FUNCTION RL_GetGamepadAxisMovement#: gamepad, axis  // Return axis movement value for a gamepad axis
INLINE
	return LIB::GetGamepadAxisMovement(gamepad, axis);
ENDINLINE
ENDFUNCTION

////------------------------------
//// Input-related functions: mouse
////------------------------------
FUNCTION RL_IsMouseButtonPressed: button  // Detect if a mouse button has been pressed once
INLINE
	return LIB::IsMouseButtonPressed(button);
ENDINLINE
ENDFUNCTION

FUNCTION RL_IsMouseButtonDown: button  // Detect if a mouse button is being pressed
INLINE
	return LIB::IsMouseButtonDown(button);
ENDINLINE
ENDFUNCTION

FUNCTION RL_IsMouseButtonReleased: button  // Detect if a mouse button has been released once
INLINE
	return LIB::IsMouseButtonReleased(button);
ENDINLINE
ENDFUNCTION

FUNCTION RL_IsMouseButtonUp: button  // Detect if a mouse button is NOT being pressed
INLINE
	return LIB::IsMouseButtonUp(button);
ENDINLINE
ENDFUNCTION

FUNCTION RL_GetMouseX:  // Returns mouse position X
INLINE
	return LIB::GetMouseX();
ENDINLINE
ENDFUNCTION

FUNCTION RL_GetMouseY:  // Returns mouse position Y
INLINE
	return LIB::GetMouseY();
ENDINLINE
ENDFUNCTION

FUNCTION RL_GetMousePosition AS RL_Vector2:  // Returns mouse position XY
INLINE
	LIB::Vector2 vec;
	vec = LIB::GetMousePosition();
	return RaylibVector2_to_GLBasicVector2(&vec);
ENDINLINE
ENDFUNCTION

FUNCTION RL_SetMousePosition: x, y  // Set mouse position XY
INLINE
	LIB::SetMousePosition(x, y);
ENDINLINE
ENDFUNCTION

FUNCTION RL_SetMouseOffset: offsetX, offsetY  // Set mouse offset
INLINE
	LIB::SetMouseOffset(offsetX, offsetY);
ENDINLINE
ENDFUNCTION

FUNCTION RL_SetMouseScale: scaleX#, scaleY#  // Set mouse scaling
INLINE
	LIB::SetMouseScale(scaleX, scaleY);
ENDINLINE
ENDFUNCTION

FUNCTION RL_GetMouseWheelMove:  // Returns mouse wheel movement Y
INLINE
	return LIB::GetMouseWheelMove();
ENDINLINE
ENDFUNCTION

////------------------------------
//// Input-related functions: touch
////------------------------------
FUNCTION RL_GetTouchX:  // Returns touch position X for touch point 0
INLINE
	return LIB::GetTouchX();
ENDINLINE
ENDFUNCTION

FUNCTION RL_GetTouchY:  // Returns touch position Y for touch point 0
INLINE
	return LIB::GetTouchY();
ENDINLINE
ENDFUNCTION

FUNCTION RL_GetTouchPosition AS RL_Vector2: index  // Returns touch position XY for a touch point index
INLINE
	LIB::Vector2 vec;
	vec =  LIB::GetTouchPosition(index);
	return RaylibVector2_to_GLBasicVector2(&vec);
ENDINLINE
ENDFUNCTION

////------------------------------
//// Gestures and Touch Handling Functions (Module: gestures)
////------------------------------
FUNCTION RL_SetGesturesEnabled: gestureFlags  // Enable a set of gestures using flags
INLINE
	LIB::SetGesturesEnabled((unsigned int)gestureFlags);
ENDINLINE
ENDFUNCTION

FUNCTION RL_IsGestureDetected: gesture  // Check if a gesture have been detected
INLINE
	return LIB::IsGestureDetected(gesture);
ENDINLINE
ENDFUNCTION

FUNCTION RL_GetGestureDetected:  // Get latest detected gesture
INLINE
	return LIB::GetGestureDetected();
ENDINLINE
ENDFUNCTION

FUNCTION RL_GetTouchPointsCount:  // Get touch points count
INLINE
	return LIB::GetTouchPointsCount();
ENDINLINE
ENDFUNCTION

FUNCTION RL_GetGestureHoldDuration#:  // Get gesture hold time in milliseconds
INLINE
	return LIB::GetGestureHoldDuration();
ENDINLINE
ENDFUNCTION

FUNCTION GetGestureDragVector AS RL_Vector2:  // Get gesture drag vector
INLINE
	LIB::Vector2 vec;
	vec =  LIB::GetGestureDragVector();
	return RaylibVector2_to_GLBasicVector2(&vec);
ENDINLINE
ENDFUNCTION

FUNCTION RL_GetGestureDragAngle:  // Get gesture drag angle
INLINE
	return LIB::GetGestureDragAngle();
ENDINLINE
ENDFUNCTION

FUNCTION RL_GetGesturePinchVector AS RL_Vector2:   // Get gesture pinch delta
INLINE
	LIB::Vector2 vec;
	vec =  LIB::GetGesturePinchVector();
	return RaylibVector2_to_GLBasicVector2(&vec);
ENDINLINE
ENDFUNCTION

FUNCTION RL_GetGesturePinchAngle#:  // Get gesture pinch angle
INLINE
	return LIB::GetGesturePinchAngle();
ENDINLINE
ENDFUNCTION

////------------------------------
//// Camera System Functions (Module: camera)
////------------------------------
//FUNCTION RL_SetCameraMode: Camera camera, int mode  // Set camera mode
//INLINE
//	LIB::SetCameraMode(Camera camera, int mode);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION RL_UpdateCamera: Camera *camera  // Update camera position for selected mode
//INLINE
//	LIB::UpdateCamera(Camera *camera);
//ENDINLINE
//ENDFUNCTION

FUNCTION RL_SetCameraPanControl: panKey  // Set camera pan key to combine with mouse movement
INLINE
	LIB::SetCameraPanControl(panKey);
ENDINLINE
ENDFUNCTION

FUNCTION RL_SetCameraAltControl: altKey  // Set camera alt key to combine with mouse movement
INLINE
	LIB::SetCameraAltControl(altKey);
ENDINLINE
ENDFUNCTION

FUNCTION RL_SetCameraSmoothZoomControl: szKey  // Set camera smooth zoom key to combine with mouse
INLINE
	LIB::SetCameraSmoothZoomControl(szKey);
ENDINLINE
ENDFUNCTION

FUNCTION RL_SetCameraMoveControls: frontKey, backKey, rightKey, leftKey, upKey, downKey  // Set camera move controls   1st person and 3rd person cameras
INLINE
	LIB::SetCameraMoveControls(frontKey, backKey, rightKey, leftKey, upKey, downKey);
ENDINLINE
ENDFUNCTION






SUB _RAYLIB_TEXTURES:
ENDSUB

////------------------------------
//// Image loading functions
////------------------------------
////------------------------------
//// NOTE: This functions do not require GPU access
////------------------------------
FUNCTION RL_LoadImage AS RL_Image: fileName$  // Load image from file into CPU memory
INLINE
	LIB::Image img;
	img =  LIB::LoadImage(fileName_Str.c_str());
	return RaylibImage_to_GLBasicImage(&img);
ENDINLINE
ENDFUNCTION

//FUNCTION LoadImageEx: Color *pixels, int width, int height  // Load image from Color array data
//INLINE
//	return LIB::LoadImageEx(Color *pixels, int width, int height);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION LoadImagePro: void *DATA, int width, int height, int format  // Load image from raw data with parameters
//INLINE
//	return LIB::LoadImagePro(void *data, int width, int height, int format);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION LoadImageRaw: const char *fileName, int width, int height, int format, int headerSize  // Load image from RAW file data
//INLINE
//	return LIB::LoadImageRaw(const char *fileName, int width, int height, int format, int headerSize);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION RL_UnloadImage: Image image  // Unload image from CPU memory
//INLINE
//	LIB::UnloadImage(Image image);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION RL_ExportImage: Image image, const char *fileName  // Export image data to file
//INLINE
//	LIB::ExportImage(Image image, const char *fileName);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION RL_ExportImageAsCode: Image image, const char *fileName  // Export image as code file defining an array of bytes
//INLINE
//	LIB::ExportImageAsCode(Image image, const char *fileName);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION *GetImageData: Image image  // Get pixel data from image as a Color struct array
//INLINE
//	return LIB::*GetImageData(Image image);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION *GetImageDataNormalized: Image image  // Get pixel data from image as Vector4 array
//INLINE
//	return LIB::*GetImageDataNormalized(Image image);
//ENDINLINE
//ENDFUNCTION
//
////------------------------------
//// Image generation functions
////------------------------------
//FUNCTION GenImageColor: int width, int height, Color color  // Generate image: plain color
//INLINE
//	return LIB::GenImageColor(int width, int height, Color color);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION GenImageGradientV: int width, int height, Color top, Color bottom  // Generate image: vertical gradient
//INLINE
//	return LIB::GenImageGradientV(int width, int height, Color top, Color bottom);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION GenImageGradientH: int width, int height, Color left, Color right  // Generate image: horizontal gradient
//INLINE
//	return LIB::GenImageGradientH(int width, int height, Color left, Color right);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION GenImageGradientRadial: int width, int height, float density, Color inner, Color outer  // Generate image: radial gradient
//INLINE
//	return LIB::GenImageGradientRadial(int width, int height, float density, Color inner, Color outer);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION GenImageChecked: int width, int height, int checksX, int checksY, Color col1, Color col2  // Generate image: checked
//INLINE
//	return LIB::GenImageChecked(int width, int height, int checksX, int checksY, Color col1, Color col2);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION GenImageWhiteNoise: int width, int height, float factor  // Generate image: white noise
//INLINE
//	return LIB::GenImageWhiteNoise(int width, int height, float factor);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION GenImagePerlinNoise: int width, int height, int offsetX, int offsetY, float scale  // Generate image: perlin noise
//INLINE
//	return LIB::GenImagePerlinNoise(int width, int height, int offsetX, int offsetY, float scale);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION GenImageCellular: int width, int height, int tileSize  // Generate image: cellular algorithm. Bigger tileSize means bigger cells
//INLINE
//	return LIB::GenImageCellular(int width, int height, int tileSize);
//ENDINLINE
//ENDFUNCTION
//
////------------------------------
//// Image manipulation functions
////------------------------------
//FUNCTION ImageCopy: Image image  // Create an image duplicate
//INLINE
//	return LIB::ImageCopy(Image image);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION ImageFromImage: Image image, Rectangle rec  // Create an image from another image piece
//INLINE
//	return LIB::ImageFromImage(Image image, Rectangle rec);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION ImageText: const char *text, int fontSize, Color color  // Create an image from text
//INLINE
//	return LIB::ImageText(const char *text, int fontSize, Color color);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION ImageTextEx: Font font, const char *text, float fontSize, float spacing, Color tint  // Create an image from text
//INLINE
//	return LIB::ImageTextEx(Font font, const char *text, float fontSize, float spacing, Color tint);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION RL_ImageToPOT: Image *image, Color fillColor  // Convert image to POT
//INLINE
//	LIB::ImageToPOT(Image *image, Color fillColor);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION RL_ImageFormat: Image *image, int newFormat  // Convert image data to desired format
//INLINE
//	LIB::ImageFormat(Image *image, int newFormat);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION RL_ImageAlphaMask: Image *image, Image alphaMask  // Apply alpha mask to image
//INLINE
//	LIB::ImageAlphaMask(Image *image, Image alphaMask);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION RL_ImageAlphaClear: Image *image, Color color, float threshold  // Clear alpha channel to desired color
//INLINE
//	LIB::ImageAlphaClear(Image *image, Color color, float threshold);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION RL_ImageAlphaCrop: Image *image, float threshold  // Crop image depending on alpha value
//INLINE
//	LIB::ImageAlphaCrop(Image *image, float threshold);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION RL_ImageAlphaPremultiply: Image *image  // Premultiply alpha channel
//INLINE
//	LIB::ImageAlphaPremultiply(Image *image);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION RL_ImageCrop: Image *image, Rectangle crop  // Crop an image to a defined rectangle
//INLINE
//	LIB::ImageCrop(Image *image, Rectangle crop);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION RL_ImageResize: Image *image, int newWidth, int newHeight  // Resize image
//INLINE
//	LIB::ImageResize(Image *image, int newWidth, int newHeight);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION RL_ImageResizeNN: Image *image, int newWidth,int newHeight  // Resize image
//INLINE
//	LIB::ImageResizeNN(Image *image, int newWidth,int newHeight);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION RL_ImageResizeCanvas: Image *image, int newWidth, int newHeight, int offsetX, int offsetY, Color color  // Resize canvas and fill with color
//INLINE
//	LIB::ImageResizeCanvas(Image *image, int newWidth, int newHeight, int offsetX, int offsetY, Color color);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION RL_ImageMipmaps: Image *image  // Generate all mipmap levels for a provided image
//INLINE
//	LIB::ImageMipmaps(Image *image);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION RL_ImageDither: Image *image, int rBpp, int gBpp, int bBpp, int aBpp  // Dither image data to 16bpp or lower
//INLINE
//	LIB::ImageDither(Image *image, int rBpp, int gBpp, int bBpp, int aBpp);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION RL_ImageFlipVertical: Image *image  // Flip image vertically
//INLINE
//	LIB::ImageFlipVertical(Image *image);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION RL_ImageFlipHorizontal: Image *image  // Flip image horizontally
//INLINE
//	LIB::ImageFlipHorizontal(Image *image);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION RL_ImageRotateCW: Image *image  // Rotate image clockwise 90deg
//INLINE
//	LIB::ImageRotateCW(Image *image);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION RL_ImageRotateCCW: Image *image  // Rotate image counter-clockwise 90deg
//INLINE
//	LIB::ImageRotateCCW(Image *image);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION RL_ImageColorTint: Image *image, Color color  // Modify image color: tint
//INLINE
//	LIB::ImageColorTint(Image *image, Color color);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION RL_ImageColorInvert: Image *image  // Modify image color: invert
//INLINE
//	LIB::ImageColorInvert(Image *image);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION RL_ImageColorGrayscale: Image *image  // Modify image color: grayscale
//INLINE
//	LIB::ImageColorGrayscale(Image *image);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION RL_ImageColorContrast: Image *image, float contrast  // Modify image color: contrast
//INLINE
//	LIB::ImageColorContrast(Image *image, float contrast);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION RL_ImageColorBrightness: Image *image, int brightness  // Modify image color: brightness
//INLINE
//	LIB::ImageColorBrightness(Image *image, int brightness);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION RL_ImageColorReplace: Image *image, Color color, Color replace  // Modify image color: replace color
//INLINE
//	LIB::ImageColorReplace(Image *image, Color color, Color replace);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION *ImageExtractPalette: Image image, int maxPaletteSize, int *extractCount  // Extract color palette from image to maximum size
//INLINE
//	return LIB::*ImageExtractPalette(Image image, int maxPaletteSize, int *extractCount);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION GetImageAlphaBorder: Image image, float threshold  // Get image alpha border rectangle
//INLINE
//	return LIB::GetImageAlphaBorder(Image image, float threshold);
//ENDINLINE
//ENDFUNCTION
//
////------------------------------
//// Image drawing functions
////------------------------------
////------------------------------
//// NOTE: Image software-rendering functions (CPU)
////------------------------------
//FUNCTION RL_ImageClearBackground: Image *dst, Color color  // Clear image background with given color
//INLINE
//	LIB::ImageClearBackground(Image *dst, Color color);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION RL_ImageDrawPixel: Image *dst, int posX, int posY, Color color  // Draw pixel within an image
//INLINE
//	LIB::ImageDrawPixel(Image *dst, int posX, int posY, Color color);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION RL_ImageDrawPixelV: Image *dst, Vector2 position, Color color  // Draw pixel within an image
//INLINE
//	LIB::ImageDrawPixelV(Image *dst, Vector2 position, Color color);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION RL_ImageDrawLine: Image *dst, int startPosX, int startPosY, int endPosX, int endPosY, Color color  // Draw line within an image
//INLINE
//	LIB::ImageDrawLine(Image *dst, int startPosX, int startPosY, int endPosX, int endPosY, Color color);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION RL_ImageDrawLineV: Image *dst, Vector2 start, Vector2 end, Color color  // Draw line within an image
//INLINE
//	LIB::ImageDrawLineV(Image *dst, Vector2 start, Vector2 end, Color color);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION RL_ImageDrawCircle: Image *dst, int centerX, int centerY, int radius, Color color  // Draw circle within an image
//INLINE
//	LIB::ImageDrawCircle(Image *dst, int centerX, int centerY, int radius, Color color);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION RL_ImageDrawCircleV: Image *dst, Vector2 center, int radius, Color color  // Draw circle within an image
//INLINE
//	LIB::ImageDrawCircleV(Image *dst, Vector2 center, int radius, Color color);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION RL_ImageDrawRectangle: Image *dst, int posX, int posY, int width, int height, Color color  // Draw rectangle within an image
//INLINE
//	LIB::ImageDrawRectangle(Image *dst, int posX, int posY, int width, int height, Color color);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION RL_ImageDrawRectangleV: Image *dst, Vector2 position, Vector2 size, Color color  // Draw rectangle within an image
//INLINE
//	LIB::ImageDrawRectangleV(Image *dst, Vector2 position, Vector2 size, Color color);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION RL_ImageDrawRectangleRec: Image *dst, Rectangle rec, Color color  // Draw rectangle within an image
//INLINE
//	LIB::ImageDrawRectangleRec(Image *dst, Rectangle rec, Color color);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION RL_ImageDrawRectangleLines: Image *dst, Rectangle rec, int thick, Color color  // Draw rectangle lines within an image
//INLINE
//	LIB::ImageDrawRectangleLines(Image *dst, Rectangle rec, int thick, Color color);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION RL_ImageDraw: Image *dst, Image src, Rectangle srcRec, Rectangle dstRec, Color tint  // Draw a source image within a destination image
//INLINE
//	LIB::ImageDraw(Image *dst, Image src, Rectangle srcRec, Rectangle dstRec, Color tint);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION RL_ImageDrawText: Image *dst, Vector2 position, const char *text, int fontSize, Color color  // Draw text
//INLINE
//	LIB::ImageDrawText(Image *dst, Vector2 position, const char *text, int fontSize, Color color);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION RL_ImageDrawTextEx: Image *dst, Vector2 position, Font font, const char *text, float fontSize, float spacing, Color color  // Draw text
//INLINE
//	LIB::ImageDrawTextEx(Image *dst, Vector2 position, Font font, const char *text, float fontSize, float spacing, Color color);
//ENDINLINE
//ENDFUNCTION
//
////------------------------------
//// Texture loading functions
////------------------------------
////------------------------------
//// NOTE: These functions require GPU access
////------------------------------
FUNCTION RL_LoadTexture AS RL_Texture2D: fileName$  // Load texture from file into GPU memory
INLINE
	LIB::Texture2D tex;
	tex = LIB::LoadTexture(fileName_Str.c_str());
	return RaylibTexture2D_to_GLBasicTexture2D(&tex);
ENDINLINE
ENDFUNCTION
//
//FUNCTION LoadTextureFromImage: Image image  // Load texture from image data
//INLINE
//	return LIB::LoadTextureFromImage(Image image);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION LoadTextureCubemap: Image image, int layoutType  // Load cubemap from image, multiple image cubemap layouts supported
//INLINE
//	return LIB::LoadTextureCubemap(Image image, int layoutType);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION LoadRenderTexture: int width, int height  // Load texture for rendering
//INLINE
//	return LIB::LoadRenderTexture(int width, int height);
//ENDINLINE
//ENDFUNCTION
//
FUNCTION RL_UnloadTexture: texture AS RL_Texture2D // Unload texture from GPU memory
INLINE
	LIB::UnloadTexture(GLBasicTexture2D_to_RaylibTexture2D( texture ));
ENDINLINE
ENDFUNCTION

//FUNCTION RL_UnloadRenderTexture: RenderTexture2D target  // Unload render texture from GPU memory
//INLINE
//	LIB::UnloadRenderTexture(RenderTexture2D target);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION RL_UpdateTexture: Texture2D texture, const void *pixels  // Update GPU texture with new data
//INLINE
//	LIB::UpdateTexture(Texture2D texture, const void *pixels);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION GetTextureData: Texture2D texture  // Get pixel data from GPU texture and return an Image
//INLINE
//	return LIB::GetTextureData(Texture2D texture);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION GetScreenData: void  // Get pixel data from screen buffer and return an Image
//INLINE
//	return LIB::GetScreenData(void);
//ENDINLINE
//ENDFUNCTION
//
////------------------------------
//// Texture configuration functions
////------------------------------
//FUNCTION RL_GenTextureMipmaps: Texture2D *texture  // Generate GPU mipmaps for a texture
//INLINE
//	LIB::GenTextureMipmaps(Texture2D *texture);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION RL_SetTextureFilter: Texture2D texture, int filterMode  // Set texture scaling filter mode
//INLINE
//	LIB::SetTextureFilter(Texture2D texture, int filterMode);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION RL_SetTextureWrap: Texture2D texture, int wrapMode  // Set texture wrapping mode
//INLINE
//	LIB::SetTextureWrap(Texture2D texture, int wrapMode);
//ENDINLINE
//ENDFUNCTION
//
////------------------------------
//// Texture drawing functions
////------------------------------
FUNCTION RL_DrawTexture: texture AS RL_Texture2D, posX, posY, _color AS RL_Color   // Draw a Texture2D
INLINE
	LIB::DrawTexture( GLBasicTexture2D_to_RaylibTexture2D(texture), posX, posY, GLBasicColor_to_RaylibColor(_color));
ENDINLINE
ENDFUNCTION

//FUNCTION RL_DrawTextureV: Texture2D texture, Vector2 position, Color tint  // Draw a Texture2D with position defined as Vector2
//INLINE
//	LIB::DrawTextureV(Texture2D texture, Vector2 position, Color tint);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION RL_DrawTextureEx: Texture2D texture, Vector2 position, float rotation, float scale, Color tint  // Draw a Texture2D with extended parameters
//INLINE
//	LIB::DrawTextureEx(Texture2D texture, Vector2 position, float rotation, float scale, Color tint);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION RL_DrawTextureRec: Texture2D texture, Rectangle sourceRec, Vector2 position, Color tint  // Draw a part of a texture defined by a rectangle
//INLINE
//	LIB::DrawTextureRec(Texture2D texture, Rectangle sourceRec, Vector2 position, Color tint);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION RL_DrawTextureQuad: Texture2D texture, Vector2 tiling, Vector2 offset, Rectangle quad, Color tint  // Draw texture quad with tiling and offset parameters
//INLINE
//	LIB::DrawTextureQuad(Texture2D texture, Vector2 tiling, Vector2 offset, Rectangle quad, Color tint);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION RL_DrawTexturePro: Texture2D texture, Rectangle sourceRec, Rectangle destRec, Vector2 origin, float rotation, Color tint  // Draw a part of a texture defined by a rectangle with 'pro' parameters
//INLINE
//	LIB::DrawTexturePro(Texture2D texture, Rectangle sourceRec, Rectangle destRec, Vector2 origin, float rotation, Color tint);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION RL_DrawTextureNPatch: Texture2D texture, NPatchInfo nPatchInfo, Rectangle destRec, Vector2 origin, float rotation, Color tint  // Draws a texture
//INLINE
//	LIB::DrawTextureNPatch(Texture2D texture, NPatchInfo nPatchInfo, Rectangle destRec, Vector2 origin, float rotation, Color tint);
//ENDINLINE
//ENDFUNCTION
//
////------------------------------
//// Image/Texture misc functions
////------------------------------
//FUNCTION RL_GetPixelDataSize: int width, int height, int format
//INLINE
//	return LIB::GetPixelDataSize(int width, int height, int format);
//ENDINLINE
//ENDFUNCTION







SUB _RAYLIB_TEXT:
	// JUST FOR QUICKJUMPING IN SOURCE!
ENDSUB

//------------------------------
// Font loading/unloading functions
//------------------------------
FUNCTION RL_GetFontDefault AS RL_Font:  // Get the default Font
INLINE
	LIB::Font f; // raylib Font
	RL_Font fnt;	// GLB Type Font
	f = LIB::GetFontDefault();
	fnt = RaylibFont_to_GLBasicFont(&f);

	return fnt;
ENDINLINE
ENDFUNCTION

FUNCTION RL_LoadFont AS RL_Font: fileName$  // Load font from file into GPU memory
INLINE
	RL_Font fnt;
	LIB::Font f;
	f = LIB::LoadFont(fileName_Str.c_str());
	fnt = RaylibFont_to_GLBasicFont(&f);
	return fnt;
ENDINLINE
ENDFUNCTION

FUNCTION RL_LoadFontEx AS RL_Font: fileName$, fontSize, fontChars, charsCount  // Load font from file with extended parameters
INLINE
	LIB::Font f;
	RL_Font fnt;
	f = LIB::LoadFontEx(fileName_Str.c_str(), fontSize, 0, charsCount);
	fnt = RaylibFont_to_GLBasicFont(&f);

	return fnt;
ENDINLINE
ENDFUNCTION

//FUNCTION RL_LoadFontFromImage: Image image, Color KEY, int firstChar  // Load font from Image
//INLINE
//	return LIB::LoadFontFromImage(Image image, Color key, int firstChar);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION *RL_LoadFontData: const char *fileName, int fontSize, int *fontChars, int charsCount, int TYPE  // Load font data for further use
//INLINE
//	return LIB::*LoadFontData(const char *fileName, int fontSize, int *fontChars, int charsCount, int type);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION RL_GenImageFontAtlas: const CharInfo *chars, Rectangle **recs, int charsCount, int fontSize, int padding, int packMethod  // Generate image font atlas using chars info
//INLINE
//	return LIB::GenImageFontAtlas(const CharInfo *chars, Rectangle **recs, int charsCount, int fontSize, int padding, int packMethod);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION RL_UnloadFont: Font font  // Unload Font from GPU memory
//INLINE
//	LIB::UnloadFont(Font font);
//ENDINLINE
//ENDFUNCTION
//
////------------------------------
//// Text drawing functions
////------------------------------
FUNCTION RL_DrawFPS: posX, posY  // Shows current FPS
INLINE
	LIB::DrawFPS(posX, posY);
ENDINLINE
ENDFUNCTION

FUNCTION RL_DrawText: text$, posX, posY, fontSize, _color AS RL_Color  // Draw text
INLINE
	LIB::DrawText(text_Str.c_str(), posX, posY, fontSize, GLBasicColor_to_RaylibColor(_color) );
ENDINLINE
ENDFUNCTION

FUNCTION RL_DrawTextEx: _font AS RL_Font, text$, posX, posY, fontSize#, spacing#, _color AS RL_Color  // Draw text using font and additional parameters
INLINE
	LIB::Font fnt;
	fnt = GLBasicFont_to_RaylibFont(_font);
	LIB::DrawTextEx(fnt, text_Str.c_str(), (LIB::Vector2){(float)posX, (float)posY}, (float)fontSize, (float)spacing, GLBasicColor_to_RaylibColor(_color));
ENDINLINE
ENDFUNCTION

//FUNCTION RL_DrawTextRec: Font font, const char *text, Rectangle rec, float fontSize, float spacing, bool wordWrap, Color tint  // Draw text using font inside rectangle limits
//INLINE
//	LIB::DrawTextRec(Font font, const char *text, Rectangle rec, float fontSize, float spacing, bool wordWrap, Color tint);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION RL_DrawTextCodepoint: Font font, int codepoint, Vector2 position, float scale, Color tint  // Draw one character
//INLINE
//	LIB::DrawTextCodepoint(Font font, int codepoint, Vector2 position, float scale, Color tint);
//ENDINLINE
//ENDFUNCTION
//
////------------------------------
//// Text misc. functions
////------------------------------
//FUNCTION RL_MeasureText: const char *text, int fontSize  // Measure string width for default font
//INLINE
//	return LIB::MeasureText(const char *text, int fontSize);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION RL_MeasureTextEx: Font font, const char *text, float fontSize, float spacing  // Measure string size for Font
//INLINE
//	return LIB::MeasureTextEx(Font font, const char *text, float fontSize, float spacing);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION RL_GetGlyphIndex: Font font, int codepoint  // Get index position for a unicode character on font
//INLINE
//	return LIB::GetGlyphIndex(Font font, int codepoint);
//ENDINLINE
//ENDFUNCTION
//
////------------------------------
//// Text strings management functions (no utf8 strings, only byte chars)
////------------------------------
////------------------------------
//// NOTE: Some strings allocate memory internally for returned strings, just be careful!
////------------------------------
//FUNCTION RL_TextCopy: char *dst, const char *src  // Copy one string to another, returns bytes copied
//INLINE
//	return LIB::TextCopy(char *dst, const char *src);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION RL_TextIsEqual: const char *text1, const char *text2  // Check if two text string are equal
//INLINE
//	return LIB::TextIsEqual(const char *text1, const char *text2);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION int: const char *text  // Get text length, checks for '\0' ending
//INLINE
//	return LIB::int(const char *text);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION char: const char *text, ...  // Text formatting with variables
//INLINE
//	return LIB::char(const char *text, ...);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION char: const char *text, int position, int length  // Get a piece of a text string
//INLINE
//	return LIB::char(const char *text, int position, int length);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION *RL_TextReplace: char *text, const char *replace, const char *by  // Replace text string
//INLINE
//	return LIB::*TextReplace(char *text, const char *replace, const char *by);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION *RL_TextInsert: const char *text, const char *insert, int position  // Insert text in a position
//INLINE
//	return LIB::*TextInsert(const char *text, const char *insert, int position);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION char: const char **textList, int count, const char *delimiter  // Join text strings with delimiter
//INLINE
//	return LIB::char(const char **textList, int count, const char *delimiter);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION char: const char *text, char delimiter, int *count  // Split text into multiple strings
//INLINE
//	return LIB::char(const char *text, char delimiter, int *count);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION RL_TextAppend: char *text, const char *append, int *position  // Append text at specific position and move cursor!
//INLINE
//	LIB::TextAppend(char *text, const char *append, int *position);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION RL_TextFindIndex: const char *text, const char *find  // Find first text occurrence within a string
//INLINE
//	return LIB::TextFindIndex(const char *text, const char *find);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION char: const char *text  // Get upper case version of provided string
//INLINE
//	return LIB::char(const char *text);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION char: const char *text  // Get lower case version of provided string
//INLINE
//	return LIB::char(const char *text);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION char: const char *text  // Get Pascal case notation version of provided string
//INLINE
//	return LIB::char(const char *text);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION RL_TextToInteger: const char *text  // Get integer value from text
//INLINE
//	return LIB::TextToInteger(const char *text);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION *RL_TextToUtf8: int *codepoints, int length  // Encode text codepoint into utf8 text
//INLINE
//	return LIB::*TextToUtf8(int *codepoints, int length);
//ENDINLINE
//ENDFUNCTION
//
////------------------------------
//// UTF8 text strings management functions
////------------------------------
//FUNCTION *RL_GetCodepoints: const char *text, int *count  // Get all codepoints in a string, codepoints count returned by parameters
//INLINE
//	return LIB::*GetCodepoints(const char *text, int *count);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION RL_GetCodepointsCount: const char *text  // Get total number of characters
//INLINE
//	return LIB::GetCodepointsCount(const char *text);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION RL_GetNextCodepoint: const char *text, int *bytesProcessed  // Returns next codepoint in a UTF8 encoded string; 0x3f
//INLINE
//	return LIB::GetNextCodepoint(const char *text, int *bytesProcessed);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION char: int codepoint, int *byteLength  // Encode codepoint into utf8 text
//INLINE
//	return LIB::char(int codepoint, int *byteLength);
//ENDINLINE
//ENDFUNCTION


// TESTING STUFF!!!!!
SUB _TESTINGAREA:
ENDSUB


FUNCTION RL_GenTextureMipmaps: _font AS RL_Font
INLINE
	LIB::Font f;
	f = GLBasicFont_to_RaylibFont(_font);
	LIB::GenTextureMipmaps(&f.texture);
	_font = RaylibFont_to_GLBasicFont(&f);
ENDINLINE
ENDFUNCTION
