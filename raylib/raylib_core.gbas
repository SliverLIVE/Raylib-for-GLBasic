// --------------------------------- //
// Project: RayLib
// Start: Sunday, May 03, 2020
// IDE Version: 16.508


INLINE
}
#include <stdlib.h> // malloc, free, rand

namespace LIB{
	#include "raylib.h"
}
	
	RL_Vector2 RaylibVector2_to_GLBasicVector2(LIB::Vector2 *v2)
	{
		RL_Vector2 vec2;
		vec2.x = v2->x;
		vec2.y = v2->y;
		return vec2;
	}
	
	LIB::Vector2 GLBasicColor_to_RaylibColor(RL_Vector2 v2)
	{
		LIB::Vector2 vec2;
		vec2.x = v2.x;
		vec2.y = v2.y;
		return vec2;				
	}
	
	RL_Color RaylibColor_to_GLBasicColor(LIB::Color *c)
	{
		RL_Color col;
		col.r = c->r;
		col.g = c->g;
		col.b = c->b;
		col.a = c->a;

		return col;
	}

	LIB::Color GLBasicColor_to_RaylibColor(RL_Color c)
	{
		LIB::Color col;
		col.r = c.r;
		col.g = c.g;
		col.b = c.b;
		col.a = c.a;

		return col;
	}

	RL_Font RaylibFont_to_GLBasicFont(LIB::Font *f)
	{
		RL_Font fnt;
		fnt.baseSize 		= f->baseSize;
		fnt.charsCount 		= f->charsCount;
		fnt.texture.id 		= f->texture.id;
		fnt.texture.width 	= f->texture.width;
		fnt.texture.height	= f->texture.height;
		fnt.texture.mipmaps = f->texture.mipmaps;
		fnt.texture.format	= f->texture.format;

		for(int i = 0; i < f->charsCount; i++)
		{
			RL_Rectangle r;
			r.x 		= f->recs[i].x;
			r.y 		= f->recs[i].y;
			r.width 	= f->recs[i].width;
			r.height 	= f->recs[i].height;
			DIMPUSH(fnt.recs, r);


			RL_CharInfo c;
			c.value =  f->chars[i].value;
			c.offsetX = f->chars[i].offsetX;
			c.offsetY = f->chars[i].offsetY;
			c.advanceX = f->chars[i].advanceX;

			c._image.data_Str = (const char*)f->chars[i].image.data;
			c._image.width = f->chars[i].image.width;
			c._image.height = f->chars[i].image.height;
			c._image.mipmaps = f->chars[i].image.mipmaps;
			c._image.format = f->chars[i].image.format;
			DIMPUSH(fnt.chars, c);
		}
		return fnt;
	}


	LIB::Font GLBasicFont_to_RaylibFont(RL_Font f)
	{
		LIB::Font fnt;

		fnt.baseSize 		= f.baseSize;
		fnt.charsCount 		= f.charsCount;
		fnt.texture.id 		= f.texture.id;
		fnt.texture.width 	= f.texture.width;
		fnt.texture.height	= f.texture.height;
		fnt.texture.mipmaps = f.texture.mipmaps;
		fnt.texture.format	= f.texture.format;

		fnt.chars = (LIB::CharInfo *)malloc(fnt.charsCount*sizeof(LIB::CharInfo));
		fnt.recs = (LIB::Rectangle *)malloc(fnt.charsCount*sizeof(LIB::Rectangle));

		for(int i = 0; i < f.charsCount; i++)
		{
			// recs
			fnt.recs[i].x 		= f.recs(i).x;
			fnt.recs[i].y 		= f.recs(i).y;
			fnt.recs[i].width 	= f.recs(i).width;
			fnt.recs[i].height 	= f.recs(i).height;

			// chars
			fnt.chars[i].value = f.chars(i).value;
			fnt.chars[i].offsetX = f.chars(i).offsetX;
			fnt.chars[i].offsetY = f.chars(i).offsetY;
			fnt.chars[i].advanceX = f.chars(i).advanceX;

			//image
			fnt.chars[i].image.data = (void*)f.chars(i)._image.data_Str;
			fnt.chars[i].image.width = f.chars(i)._image.width;
			fnt.chars[i].image.height = f.chars(i)._image.height;
			fnt.chars[i].image.mipmaps = f.chars(i)._image.mipmaps;
			fnt.chars[i].image.format = f.chars(i)._image.format;
		}
		return fnt;
	}

namespace __GLBASIC__{
ENDINLINE

SUB __RAYLIB_STRUCT_WRAPPERS:
	// JUST FOR QUICKJUMPING IN SOURCE!
ENDSUB

SUB _RAYLIB_CORE:
	// JUST FOR QUICKJUMPING IN SOURCE!
ENDSUB

//------------------------------
// Window-related functions
//------------------------------
FUNCTION RL_InitWindow: width, height, title$  // Initialize window and OpenGL context

INLINE
	LIB::InitWindow(width, height, title_Str.c_str());
ENDINLINE
ENDFUNCTION

FUNCTION RL_WindowShouldClose: // Check if KEY_ESCAPE pressed or Close icon pressed
INLINE
	return LIB::WindowShouldClose();
ENDINLINE
ENDFUNCTION

FUNCTION RL_CloseWindow:  // Close window and unload OpenGL context
INLINE
	LIB::CloseWindow();
ENDINLINE
ENDFUNCTION

FUNCTION RL_IsWindowReady:  // Check if window has been initialized successfully
INLINE
	return LIB::IsWindowReady();
ENDINLINE
ENDFUNCTION

FUNCTION RL_IsWindowMinimized:  // Check if window has been minimized
INLINE
	return LIB::IsWindowMinimized();
ENDINLINE
ENDFUNCTION

FUNCTION RL_IsWindowResized:  // Check if window has been resized
INLINE
	return LIB::IsWindowResized();
ENDINLINE
ENDFUNCTION

FUNCTION RL_IsWindowHidden:  // Check if window is currently hidden
INLINE
	return LIB::IsWindowHidden();
ENDINLINE
ENDFUNCTION

FUNCTION RL_IsWindowFullscreen:  // Check if window is currently fullscreen
INLINE
	return LIB::IsWindowFullscreen();
ENDINLINE
ENDFUNCTION

FUNCTION RL_ToggleFullscreen:  // Toggle fullscreen mode
INLINE
	LIB::ToggleFullscreen();
ENDINLINE
ENDFUNCTION

FUNCTION RL_UnhideWindow:  // Show the window
INLINE
	LIB::UnhideWindow();
ENDINLINE
ENDFUNCTION

FUNCTION RL_HideWindow:  // Hide the window
INLINE
	LIB::HideWindow();
ENDINLINE
ENDFUNCTION

//FUNCTION RL_SetWindowIcon: Image image  // Set icon for window
//INLINE
//	LIB::SetWindowIcon(Image image);
//ENDINLINE
//ENDFUNCTION

FUNCTION RL_SetWindowTitle: title$  // Set title for window
INLINE
	LIB::SetWindowTitle(title_Str.c_str());
ENDINLINE
ENDFUNCTION

FUNCTION RL_SetWindowPosition: x, y  // Set window position on screen
INLINE
	LIB::SetWindowPosition(x, y);
ENDINLINE
ENDFUNCTION

FUNCTION RL_SetWindowMonitor: monitor  // Set monitor for the current window
INLINE
	LIB::SetWindowMonitor(monitor);
ENDINLINE
ENDFUNCTION

FUNCTION RL_SetWindowMinSize: width, height  // Set window minimum dimensions
INLINE
	LIB::SetWindowMinSize(width, height);
ENDINLINE
ENDFUNCTION

FUNCTION RL_SetWindowSize: width, height  // Set window dimensions
INLINE
	LIB::SetWindowSize(width, height);
ENDINLINE
ENDFUNCTION

FUNCTION RL_GetWindowHandle:   // Get native window handle
INLINE
	return (long)LIB::GetWindowHandle();
ENDINLINE
ENDFUNCTION

FUNCTION RL_GetScreenWidth:  // Get current screen width
INLINE
	return LIB::GetScreenWidth();
ENDINLINE
ENDFUNCTION

FUNCTION RL_GetScreenHeight:  // Get current screen height
INLINE
	return LIB::GetScreenHeight();
ENDINLINE
ENDFUNCTION

FUNCTION RL_GetMonitorCount:  // Get number of connected monitors
INLINE
	return LIB::GetMonitorCount();
ENDINLINE
ENDFUNCTION

FUNCTION RL_GetMonitorWidth: monitor  // Get primary monitor width
INLINE
	return LIB::GetMonitorWidth(monitor);
ENDINLINE
ENDFUNCTION

FUNCTION RL_GetMonitorHeight: monitor  // Get primary monitor height
INLINE
	return LIB::GetMonitorHeight(monitor);
ENDINLINE
ENDFUNCTION

FUNCTION RL_GetMonitorPhysicalWidth: monitor  // Get primary monitor physical width in millimetres
INLINE
	return LIB::GetMonitorPhysicalWidth(monitor);
ENDINLINE
ENDFUNCTION

FUNCTION RL_GetMonitorPhysicalHeight: monitor  // Get primary monitor physical height in millimetres
INLINE
	return LIB::GetMonitorPhysicalHeight(monitor);
ENDINLINE
ENDFUNCTION

FUNCTION RL_GetWindowPosition AS RL_Vector2:  // Get window position XY on monitor
INLINE
	LIB::Vector2 v;
	v = LIB::GetWindowPosition();
	return RaylibVector2_to_GLBasicVector2(&v);
ENDINLINE
ENDFUNCTION

FUNCTION RL_GetMonitorName$:monitor  // Get the human-readable, UTF-8 encoded name of the primary monitor
INLINE
	return LIB::GetMonitorName(monitor);
ENDINLINE
ENDFUNCTION

FUNCTION RL_GetClipboardText$:  // Get clipboard text content
INLINE
	return LIB::GetClipboardText();
ENDINLINE
ENDFUNCTION

FUNCTION RL_SetClipboardText: text$  // Set clipboard text content
INLINE
	LIB::SetClipboardText(text_Str.c_str());
ENDINLINE
ENDFUNCTION

//------------------------------
// Cursor-related functions
//------------------------------
FUNCTION RL_ShowCursor:  // Shows cursor
INLINE
	LIB::ShowCursor();
ENDINLINE
ENDFUNCTION

FUNCTION RL_HideCursor:  // Hides cursor
INLINE
	LIB::HideCursor();
ENDINLINE
ENDFUNCTION

FUNCTION RL_IsCursorHidden:  // Check if cursor is not visible
INLINE
	return LIB::IsCursorHidden();
ENDINLINE
ENDFUNCTION

FUNCTION RL_EnableCursor:  // Enables cursor
INLINE
	LIB::EnableCursor();
ENDINLINE
ENDFUNCTION

FUNCTION RL_DisableCursor:  // Disables cursor
INLINE
	LIB::DisableCursor();
ENDINLINE
ENDFUNCTION

//------------------------------
// Drawing-related functions
//------------------------------
FUNCTION RL_ClearBackground: _color AS RL_Color  // Set background color
INLINE
	LIB::ClearBackground( GLBasicColor_to_RaylibColor(_color) );
ENDINLINE
ENDFUNCTION

FUNCTION RL_BeginDrawing:  // Setup canvas
INLINE
	LIB::BeginDrawing();
ENDINLINE
ENDFUNCTION

FUNCTION RL_EndDrawing:  // End canvas drawing and swap buffers
INLINE
	LIB::EndDrawing();
ENDINLINE
ENDFUNCTION

//FUNCTION RL_BeginMode2D: Camera2D camera  // Initialize 2D mode with custom camera
//INLINE
//	LIB::BeginMode2D(Camera2D camera);
//ENDINLINE
//ENDFUNCTION

FUNCTION RL_EndMode2D:  // Ends 2D mode with custom camera
INLINE
	LIB::EndMode2D();
ENDINLINE
ENDFUNCTION

//FUNCTION RL_BeginMode3D: Camera3D camera  // Initializes 3D mode with custom camera
//INLINE
//	LIB::BeginMode3D(Camera3D camera);
//ENDINLINE
//ENDFUNCTION

FUNCTION RL_EndMode3D:  // Ends 3D mode and returns to default 2D orthographic mode
INLINE
	LIB::EndMode3D();
ENDINLINE
ENDFUNCTION

//FUNCTION BeginTextureMode: RenderTexture2D target  // Initializes render texture for drawing
//INLINE
//	LIB::BeginTextureMode(RenderTexture2D target);
//ENDINLINE
//ENDFUNCTION

FUNCTION RL_EndTextureMode:  // Ends drawing to render texture
INLINE
	LIB::EndTextureMode();
ENDINLINE
ENDFUNCTION

FUNCTION RL_BeginScissorMode: x, y, width, height  // Begin scissor mode
INLINE
	LIB::BeginScissorMode(x, y, width, height);
ENDINLINE
ENDFUNCTION

FUNCTION RL_EndScissorMode:  // End scissor mode
INLINE
	LIB::EndScissorMode();
ENDINLINE
ENDFUNCTION

////------------------------------
//// Screen-space-related functions
////------------------------------
//FUNCTION RL_GetMouseRay: Vector2 mousePosition, Camera camera  // Returns a ray trace from mouse position
//INLINE
//	return LIB::GetMouseRay(Vector2 mousePosition, Camera camera);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION RL_GetCameraMatrix: Camera camera  // Returns camera transform matrix
//INLINE
//	return LIB::GetCameraMatrix(Camera camera);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION RL_GetCameraMatrix2D: Camera2D camera  // Returns camera 2d transform matrix
//INLINE
//	return LIB::GetCameraMatrix2D(Camera2D camera);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION RL_GetWorldToScreen: Vector3 position, Camera camera  // Returns the screen space position for a 3d world space position
//INLINE
//	return LIB::GetWorldToScreen(Vector3 position, Camera camera);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION RL_GetWorldToScreenEx: Vector3 position, Camera camera,int width, int height  // Returns size position for a 3d world space position
//INLINE
//	return LIB::GetWorldToScreenEx(Vector3 position, Camera camera,int width, int height);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION RL_GetWorldToScreen2D: Vector2 position, Camera2D camera  // Returns the screen space position for a 2d camera world space position
//INLINE
//	return LIB::GetWorldToScreen2D(Vector2 position, Camera2D camera);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION RL_GetScreenToWorld2D: Vector2 position, Camera2D camera  // Returns the world space position for a 2d camera screen space position
//INLINE
//	return LIB::GetScreenToWorld2D(Vector2 position, Camera2D camera);
//ENDINLINE
//ENDFUNCTION
//
////------------------------------
//// Timing-related functions
////------------------------------
FUNCTION RL_SetTargetFPS: fps  // Set target FPS
INLINE
	LIB::SetTargetFPS(fps);
ENDINLINE
ENDFUNCTION

FUNCTION RL_GetFPS:  // Returns current FPS
INLINE
	return LIB::GetFPS();
ENDINLINE
ENDFUNCTION

FUNCTION RL_GetFrameTime:  // Returns time in seconds for last frame drawn
INLINE
	return LIB::GetFrameTime();
ENDINLINE
ENDFUNCTION

FUNCTION RL_GetTime:  // Returns elapsed time in seconds since InitWindow
INLINE
	return LIB::GetTime();
ENDINLINE
ENDFUNCTION

////------------------------------
//// Color-related functions
////------------------------------
FUNCTION RL_ColorToInt: r, g, b, a  // Returns hexadecimal value for a Color
INLINE
	return LIB::ColorToInt({r, g, b, a});
ENDINLINE
ENDFUNCTION

//FUNCTION RL_ColorNormalize: Color color  // Returns color normalized as float [0..1]
//INLINE
//	return LIB::ColorNormalize(Color color);
//ENDINLINE
//ENDFUNCTION

//FUNCTION RL_ColorFromNormalized: Vector4 normalized  // Returns color from normalized values [0..1]
//INLINE
//	return LIB::ColorFromNormalized(Vector4 normalized);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION RL_ColorToHSV: Color color  // Returns HSV values for a Color
//INLINE
//	return LIB::ColorToHSV(Color color);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION RL_ColorFromHSV: Vector3 hsv  // Returns a Color from HSV values
//INLINE
//	return LIB::ColorFromHSV(Vector3 hsv);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION RL_GetColor: int hexValue  // Returns a Color struct from hexadecimal value
//INLINE
//	return LIB::GetColor(int hexValue);
//ENDINLINE
//ENDFUNCTION
//
FUNCTION RL_Fade: _color AS RL_Color, alpha#  // Color fade-in or fade-out, alpha goes from 0.0f to 1.0f
INLINE
	LIB::Color c;
	c = GLBasicColor_to_RaylibColor(_color);
	
	c =  LIB::Fade(c, (float)alpha);
	
	_color = RaylibColor_to_GLBasicColor(&c);
ENDINLINE
ENDFUNCTION

////------------------------------
//// Misc. functions
////------------------------------
FUNCTION RL_SetConfigFlags: flags  // Setup window configuration flags
INLINE
	LIB::SetConfigFlags(flags);
ENDINLINE
ENDFUNCTION

FUNCTION RL_SetTraceLogLevel: logType  // Set the current threshold
INLINE
	LIB::SetTraceLogLevel(logType);
ENDINLINE
ENDFUNCTION

FUNCTION RL_SetTraceLogExit: logType  // Set the exit threshold
INLINE
	LIB::SetTraceLogExit(logType);
ENDINLINE
ENDFUNCTION

//FUNCTION RL_SetTraceLogCallback: TraceLogCallback CALLBACK  // Set a trace log callback to enable custom logging
//INLINE
//	LIB::SetTraceLogCallback(TraceLogCallback CALLBACK);
//ENDINLINE
//ENDFUNCTION

//FUNCTION RL_TraceLog: int logType, const char *text, ...  // Show trace log messages
//INLINE
//	LIB::TraceLog(int logType, const char *text, ...);
//ENDINLINE
//ENDFUNCTION

FUNCTION RL_TakeScreenshot: fileName$  // Takes a screenshot of current screen
INLINE
	LIB::TakeScreenshot(fileName_Str.c_str());
ENDINLINE
ENDFUNCTION

FUNCTION RL_GetRandomValue: valMIN, valMAX  // Returns a random value between min and max
INLINE
	return LIB::GetRandomValue(valMIN, valMAX);
ENDINLINE
ENDFUNCTION

////------------------------------
//// Files management functions
////------------------------------
FUNCTION RL_LoadFileData$: fileName$, BYREF bytesRead  // Load file data as byte array
INLINE
	unsigned int bytesread;
	unsigned char* result;
	result =  LIB::LoadFileData(fileName_Str.c_str(), &bytesread);
	bytesRead = bytesread;
	return (const char*)result;
ENDINLINE
ENDFUNCTION

FUNCTION RL_SaveFileData: fileName$, data$, bytesToWrite  // Save data to file from byte array
INLINE
	LIB::SaveFileData(fileName_Str.c_str(), (void*)data_Str.c_str(), bytesToWrite);
ENDINLINE
ENDFUNCTION

FUNCTION RL_LoadFileText$: fileName$  // Load text data from file
INLINE
	return LIB::LoadFileText(fileName_Str.c_str());
ENDINLINE
ENDFUNCTION

FUNCTION RL_SaveFileText: fileName$, text$  // Save text data to file
INLINE
	LIB::SaveFileText(fileName_Str.c_str(), (char*)text_Str.c_str());
ENDINLINE
ENDFUNCTION

FUNCTION RL_FileExists: fileName$  // Check if file exists
INLINE
	return LIB::FileExists(fileName_Str.c_str());
ENDINLINE
ENDFUNCTION

FUNCTION RL_IsFileExtension: fileName$, ext$  // Check file extension
INLINE
	return LIB::IsFileExtension(fileName_Str.c_str(), ext_Str.c_str());
ENDINLINE
ENDFUNCTION

FUNCTION RL_DirectoryExists: dirPath$  // Check if a directory path exists
INLINE
	return LIB::DirectoryExists(dirPath_Str.c_str());
ENDINLINE
ENDFUNCTION

FUNCTION RL_GetExtension$: fileName$  // Get pointer to extension for a filename string
INLINE
	return LIB::GetExtension(fileName_Str.c_str());
ENDINLINE
ENDFUNCTION

FUNCTION RL_GetFileName$: filePath$  // Get pointer to filename for a path string
INLINE
	return LIB::GetFileName(filePath_Str.c_str());
ENDINLINE
ENDFUNCTION

FUNCTION RL_GetFileNameWithoutExt$: filePath$  // Get filename string without extension
INLINE
	return LIB::GetFileNameWithoutExt(filePath_Str.c_str());
ENDINLINE
ENDFUNCTION

FUNCTION RL_GetDirectoryPath$: filePath$  // Get full path for a given fileName with path
INLINE
	return LIB::GetDirectoryPath(filePath_Str.c_str());
ENDINLINE
ENDFUNCTION

FUNCTION RL_GetPrevDirectoryPath$: dirPath$  // Get previous directory path for a given path
INLINE
	return LIB::GetPrevDirectoryPath(dirPath_Str.c_str());
ENDINLINE
ENDFUNCTION

FUNCTION RL_GetWorkingDirectory$:  // Get current working directory
INLINE
	return LIB::GetWorkingDirectory();
ENDINLINE
ENDFUNCTION

FUNCTION RL_GetDirectoryFiles: dirPath$, BYREF count, result$[]  // Get filenames in a directory path
INLINE
	int fileCount;
	char** files;

	files = LIB::GetDirectoryFiles(dirPath_Str.c_str(), &fileCount);

	DIM(result_Str, fileCount);
	for(int i = 0; i<fileCount; i++)
	{
		result_Str(i) = files[i]; // arrays in GLBasic are allways be a reference in functions!
	}
	count = fileCount;
ENDINLINE
ENDFUNCTION

FUNCTION RL_ClearDirectoryFiles:  // Clear directory files paths buffers
INLINE
	LIB::ClearDirectoryFiles();
ENDINLINE
ENDFUNCTION

FUNCTION RL_ChangeDirectory: dir$  // Change working directory, returns true if success
INLINE
	return LIB::ChangeDirectory(dir_Str.c_str());
ENDINLINE
ENDFUNCTION

FUNCTION RL_IsFileDropped:  // Check if a file has been dropped into window
INLINE
	return LIB::IsFileDropped();
ENDINLINE
ENDFUNCTION

FUNCTION RL_GetDroppedFiles: BYREF count, result$[]  // Get dropped files names
INLINE
	int fileCount;
	char** files;
	files =  LIB::GetDroppedFiles(&fileCount);

	DIM(result_Str, fileCount);
	for(int i = 0; i<fileCount; i++)
	{
		result_Str(i) = files[i]; // arrays in GLBasic are allways be a reference in functions!
	}
	count = fileCount;

ENDINLINE
ENDFUNCTION

FUNCTION RL_ClearDroppedFiles:  // Clear dropped files paths buffer
INLINE
	LIB::ClearDroppedFiles();
ENDINLINE
ENDFUNCTION

FUNCTION RL_GetFileModTime: fileName$  // Get file modification time
INLINE
	return LIB::GetFileModTime(fileName_Str.c_str());
ENDINLINE
ENDFUNCTION

FUNCTION RL_CompressData$: data$, dataLength, BYREF compDataLength  // Compress data
INLINE
	int compdatalength;
	unsigned char* result;
	result =  LIB::CompressData((unsigned char*)data_Str.c_str(), dataLength, &compdatalength);
	compDataLength = compdatalength;
	return (const char*)result;
ENDINLINE
ENDFUNCTION

FUNCTION RL_DecompressData$: compData$, compDataLength, BYREF dataLength  // Decompress data
INLINE
	int datalength;
	unsigned char* result;
	result =  LIB::DecompressData((unsigned char*)compData_Str.c_str(), compDataLength, &datalength);
	dataLength = datalength;
	return (const char*)result;
ENDINLINE
ENDFUNCTION

////------------------------------
//// Persistent storage management
////------------------------------
FUNCTION RL_LoadStorageValue: position  // Load integer value from storage file
INLINE
	return LIB::LoadStorageValue(position);
ENDINLINE
ENDFUNCTION

FUNCTION RL_SaveStorageValue: position, value  // Save integer value to storage file
INLINE
	LIB::SaveStorageValue(position, value);
ENDINLINE
ENDFUNCTION

FUNCTION RL_OpenURL: url$  // Open URL with default system browser
INLINE
	LIB::OpenURL(url_Str.c_str());
ENDINLINE
ENDFUNCTION

////------------------------------
//// Input Handling Functions
////------------------------------
////------------------------------
//// Input-related functions: keyb
////------------------------------
FUNCTION RL_IsKeyPressed: inkey  // Detect if a key has been pressed once
INLINE
	return LIB::IsKeyPressed(inkey);
ENDINLINE
ENDFUNCTION

FUNCTION RL_IsKeyDown: inkey  // Detect if a key is being pressed
INLINE
	return LIB::IsKeyDown(inkey);
ENDINLINE
ENDFUNCTION

FUNCTION RL_IsKeyReleased: inkey  // Detect if a key has been released once
INLINE
	return LIB::IsKeyReleased(inkey);
ENDINLINE
ENDFUNCTION

FUNCTION RL_IsKeyUp: inkey  // Detect if a key is NOT being pressed
INLINE
	return LIB::IsKeyUp(inkey);
ENDINLINE
ENDFUNCTION

FUNCTION RL_GetKeyPressed:   // Get latest key pressed
INLINE
	return LIB::GetKeyPressed();
ENDINLINE
ENDFUNCTION

FUNCTION RL_SetExitKey: inkey // Set a custom key to exit program
INLINE
	LIB::SetExitKey(inkey);
ENDINLINE
ENDFUNCTION

////------------------------------
//// Input-related functions: gamepads
////------------------------------
FUNCTION RL_IsGamepadAvailable: gamepad  // Detect if a gamepad is available
INLINE
	return LIB::IsGamepadAvailable(gamepad);
ENDINLINE
ENDFUNCTION

FUNCTION RL_IsGamepadName: gamepad, name$  // Check gamepad name
INLINE
	return LIB::IsGamepadName(gamepad, name_Str.c_str());
ENDINLINE
ENDFUNCTION

FUNCTION RL_GetGamepadName$: gamepad  // Return gamepad internal name id
INLINE
	return LIB::GetGamepadName(gamepad);
ENDINLINE
ENDFUNCTION

FUNCTION RL_IsGamepadButtonPressed: gamepad, button  // Detect if a gamepad button has been pressed once
INLINE
	return LIB::IsGamepadButtonPressed(gamepad, button);
ENDINLINE
ENDFUNCTION

FUNCTION RL_IsGamepadButtonDown: gamepad, button  // Detect if a gamepad button is being pressed
INLINE
	return LIB::IsGamepadButtonDown(gamepad, button);
ENDINLINE
ENDFUNCTION

FUNCTION RL_IsGamepadButtonReleased: gamepad, button  // Detect if a gamepad button has been released once
INLINE
	return LIB::IsGamepadButtonReleased(gamepad, button);
ENDINLINE
ENDFUNCTION

FUNCTION RL_IsGamepadButtonUp: gamepad, button  // Detect if a gamepad button is NOT being pressed
INLINE
	return LIB::IsGamepadButtonUp(gamepad, button);
ENDINLINE
ENDFUNCTION

FUNCTION RL_GetGamepadButtonPressed:  // Get the last gamepad button pressed
INLINE
	return LIB::GetGamepadButtonPressed();
ENDINLINE
ENDFUNCTION

FUNCTION RL_GetGamepadAxisCount: gamepad  // Return gamepad axis count for a gamepad
INLINE
	return LIB::GetGamepadAxisCount(gamepad);
ENDINLINE
ENDFUNCTION

FUNCTION RL_GetGamepadAxisMovement#: gamepad, axis  // Return axis movement value for a gamepad axis
INLINE
	return LIB::GetGamepadAxisMovement(gamepad, axis);
ENDINLINE
ENDFUNCTION

////------------------------------
//// Input-related functions: mouse
////------------------------------
FUNCTION RL_IsMouseButtonPressed: button  // Detect if a mouse button has been pressed once
INLINE
	return LIB::IsMouseButtonPressed(button);
ENDINLINE
ENDFUNCTION

FUNCTION RL_IsMouseButtonDown: button  // Detect if a mouse button is being pressed
INLINE
	return LIB::IsMouseButtonDown(button);
ENDINLINE
ENDFUNCTION

FUNCTION RL_IsMouseButtonReleased: button  // Detect if a mouse button has been released once
INLINE
	return LIB::IsMouseButtonReleased(button);
ENDINLINE
ENDFUNCTION

FUNCTION RL_IsMouseButtonUp: button  // Detect if a mouse button is NOT being pressed
INLINE
	return LIB::IsMouseButtonUp(button);
ENDINLINE
ENDFUNCTION

FUNCTION RL_GetMouseX:  // Returns mouse position X
INLINE
	return LIB::GetMouseX();
ENDINLINE
ENDFUNCTION

FUNCTION RL_GetMouseY:  // Returns mouse position Y
INLINE
	return LIB::GetMouseY();
ENDINLINE
ENDFUNCTION

//FUNCTION RL_GetMousePosition: void  // Returns mouse position XY
//INLINE
//	return LIB::GetMousePosition(void);
//ENDINLINE
//ENDFUNCTION
//
FUNCTION RL_SetMousePosition: x, y  // Set mouse position XY
INLINE
	LIB::SetMousePosition(x, y);
ENDINLINE
ENDFUNCTION

FUNCTION RL_SetMouseOffset: offsetX, offsetY  // Set mouse offset
INLINE
	LIB::SetMouseOffset(offsetX, offsetY);
ENDINLINE
ENDFUNCTION

FUNCTION RL_SetMouseScale: scaleX#, scaleY#  // Set mouse scaling
INLINE
	LIB::SetMouseScale(scaleX, scaleY);
ENDINLINE
ENDFUNCTION

FUNCTION RL_GetMouseWheelMove:  // Returns mouse wheel movement Y
INLINE
	return LIB::GetMouseWheelMove();
ENDINLINE
ENDFUNCTION

////------------------------------
//// Input-related functions: touch
////------------------------------
FUNCTION RL_GetTouchX:  // Returns touch position X for touch point 0
INLINE
	return LIB::GetTouchX();
ENDINLINE
ENDFUNCTION

FUNCTION RL_GetTouchY:  // Returns touch position Y for touch point 0
INLINE
	return LIB::GetTouchY();
ENDINLINE
ENDFUNCTION

//FUNCTION RL_GetTouchPosition: int index  // Returns touch position XY for a touch point index
//INLINE
//	return LIB::GetTouchPosition(int index);
//ENDINLINE
//ENDFUNCTION
//
////------------------------------
//// Gestures and Touch Handling Functions (Module: gestures)
////------------------------------
FUNCTION RL_SetGesturesEnabled: gestureFlags  // Enable a set of gestures using flags
INLINE
	LIB::SetGesturesEnabled((unsigned int)gestureFlags);
ENDINLINE
ENDFUNCTION

FUNCTION RL_IsGestureDetected: gesture  // Check if a gesture have been detected
INLINE
	return LIB::IsGestureDetected(gesture);
ENDINLINE
ENDFUNCTION

FUNCTION RL_GetGestureDetected:  // Get latest detected gesture
INLINE
	return LIB::GetGestureDetected();
ENDINLINE
ENDFUNCTION

FUNCTION RL_GetTouchPointsCount:  // Get touch points count
INLINE
	return LIB::GetTouchPointsCount();
ENDINLINE
ENDFUNCTION

FUNCTION RL_GetGestureHoldDuration#:  // Get gesture hold time in milliseconds
INLINE
	return LIB::GetGestureHoldDuration();
ENDINLINE
ENDFUNCTION

//FUNCTION GetGestureDragVector: void  // Get gesture drag vector
//INLINE
//	return LIB::GetGestureDragVector(void);
//ENDINLINE
//ENDFUNCTION
//
FUNCTION RL_GetGestureDragAngle:  // Get gesture drag angle
INLINE
	return LIB::GetGestureDragAngle();
ENDINLINE
ENDFUNCTION

//FUNCTION RL_GetGesturePinchVector: void  // Get gesture pinch delta
//INLINE
//	return LIB::GetGesturePinchVector(void);
//ENDINLINE
//ENDFUNCTION
//
FUNCTION RL_GetGesturePinchAngle#:  // Get gesture pinch angle
INLINE
	return LIB::GetGesturePinchAngle();
ENDINLINE
ENDFUNCTION

////------------------------------
//// Camera System Functions (Module: camera)
////------------------------------
//FUNCTION RL_SetCameraMode: Camera camera, int mode  // Set camera mode
//INLINE
//	LIB::SetCameraMode(Camera camera, int mode);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION RL_UpdateCamera: Camera *camera  // Update camera position for selected mode
//INLINE
//	LIB::UpdateCamera(Camera *camera);
//ENDINLINE
//ENDFUNCTION

FUNCTION RL_SetCameraPanControl: panKey  // Set camera pan key to combine with mouse movement
INLINE
	LIB::SetCameraPanControl(panKey);
ENDINLINE
ENDFUNCTION

FUNCTION RL_SetCameraAltControl: altKey  // Set camera alt key to combine with mouse movement
INLINE
	LIB::SetCameraAltControl(altKey);
ENDINLINE
ENDFUNCTION

FUNCTION RL_SetCameraSmoothZoomControl: szKey  // Set camera smooth zoom key to combine with mouse
INLINE
	LIB::SetCameraSmoothZoomControl(szKey);
ENDINLINE
ENDFUNCTION

FUNCTION RL_SetCameraMoveControls: frontKey, backKey, rightKey, leftKey, upKey, downKey  // Set camera move controls   1st person and 3rd person cameras
INLINE
	LIB::SetCameraMoveControls(frontKey, backKey, rightKey, leftKey, upKey, downKey);
ENDINLINE
ENDFUNCTION





SUB _RAYLIB_TEXT:
	// JUST FOR QUICKJUMPING IN SOURCE!
ENDSUB

//------------------------------
// Font loading/unloading functions
//------------------------------
FUNCTION RL_GetFontDefault AS RL_Font:  // Get the default Font
INLINE
	LIB::Font f; // raylib Font
	RL_Font fnt;	// GLB Type Font
	f = LIB::GetFontDefault();
	fnt = RaylibFont_to_GLBasicFont(&f);

	return fnt;
ENDINLINE
ENDFUNCTION

FUNCTION RL_LoadFont AS RL_Font: fileName$  // Load font from file into GPU memory
INLINE
	RL_Font fnt;
	LIB::Font f;
	f = LIB::LoadFont(fileName_Str.c_str());
	fnt = RaylibFont_to_GLBasicFont(&f);
	return fnt;
ENDINLINE
ENDFUNCTION

FUNCTION RL_LoadFontEx AS RL_Font: fileName$, fontSize, fontChars, charsCount  // Load font from file with extended parameters
INLINE
	LIB::Font f;
	RL_Font fnt;
	f = LIB::LoadFontEx(fileName_Str.c_str(), fontSize, 0, charsCount);
	fnt = RaylibFont_to_GLBasicFont(&f);

	return fnt;
ENDINLINE
ENDFUNCTION

//FUNCTION RL_LoadFontFromImage: Image image, Color KEY, int firstChar  // Load font from Image
//INLINE
//	return LIB::LoadFontFromImage(Image image, Color key, int firstChar);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION *RL_LoadFontData: const char *fileName, int fontSize, int *fontChars, int charsCount, int TYPE  // Load font data for further use
//INLINE
//	return LIB::*LoadFontData(const char *fileName, int fontSize, int *fontChars, int charsCount, int type);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION RL_GenImageFontAtlas: const CharInfo *chars, Rectangle **recs, int charsCount, int fontSize, int padding, int packMethod  // Generate image font atlas using chars info
//INLINE
//	return LIB::GenImageFontAtlas(const CharInfo *chars, Rectangle **recs, int charsCount, int fontSize, int padding, int packMethod);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION RL_UnloadFont: Font font  // Unload Font from GPU memory
//INLINE
//	LIB::UnloadFont(Font font);
//ENDINLINE
//ENDFUNCTION
//
////------------------------------
//// Text drawing functions
////------------------------------
FUNCTION RL_DrawFPS: posX, posY  // Shows current FPS
INLINE
	LIB::DrawFPS(posX, posY);
ENDINLINE
ENDFUNCTION

FUNCTION RL_DrawText: text$, posX, posY, fontSize, _color AS RL_Color  // Draw text
INLINE
	LIB::DrawText(text_Str.c_str(), posX, posY, fontSize, GLBasicColor_to_RaylibColor(_color) );
ENDINLINE
ENDFUNCTION

FUNCTION RL_DrawTextEx: _font AS RL_Font, text$, posX, posY, fontSize#, spacing#, _color AS RL_Color  // Draw text using font and additional parameters
INLINE
	LIB::Font fnt;
	fnt = GLBasicFont_to_RaylibFont(_font);
	LIB::DrawTextEx(fnt, text_Str.c_str(), (LIB::Vector2){(float)posX, (float)posY}, (float)fontSize, (float)spacing, GLBasicColor_to_RaylibColor(_color));
ENDINLINE
ENDFUNCTION

//FUNCTION RL_DrawTextRec: Font font, const char *text, Rectangle rec, float fontSize, float spacing, bool wordWrap, Color tint  // Draw text using font inside rectangle limits
//INLINE
//	LIB::DrawTextRec(Font font, const char *text, Rectangle rec, float fontSize, float spacing, bool wordWrap, Color tint);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION RL_DrawTextCodepoint: Font font, int codepoint, Vector2 position, float scale, Color tint  // Draw one character
//INLINE
//	LIB::DrawTextCodepoint(Font font, int codepoint, Vector2 position, float scale, Color tint);
//ENDINLINE
//ENDFUNCTION
//
////------------------------------
//// Text misc. functions
////------------------------------
//FUNCTION RL_MeasureText: const char *text, int fontSize  // Measure string width for default font
//INLINE
//	return LIB::MeasureText(const char *text, int fontSize);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION RL_MeasureTextEx: Font font, const char *text, float fontSize, float spacing  // Measure string size for Font
//INLINE
//	return LIB::MeasureTextEx(Font font, const char *text, float fontSize, float spacing);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION RL_GetGlyphIndex: Font font, int codepoint  // Get index position for a unicode character on font
//INLINE
//	return LIB::GetGlyphIndex(Font font, int codepoint);
//ENDINLINE
//ENDFUNCTION
//
////------------------------------
//// Text strings management functions (no utf8 strings, only byte chars)
////------------------------------
////------------------------------
//// NOTE: Some strings allocate memory internally for returned strings, just be careful!
////------------------------------
//FUNCTION RL_TextCopy: char *dst, const char *src  // Copy one string to another, returns bytes copied
//INLINE
//	return LIB::TextCopy(char *dst, const char *src);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION RL_TextIsEqual: const char *text1, const char *text2  // Check if two text string are equal
//INLINE
//	return LIB::TextIsEqual(const char *text1, const char *text2);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION int: const char *text  // Get text length, checks for '\0' ending
//INLINE
//	return LIB::int(const char *text);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION char: const char *text, ...  // Text formatting with variables
//INLINE
//	return LIB::char(const char *text, ...);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION char: const char *text, int position, int length  // Get a piece of a text string
//INLINE
//	return LIB::char(const char *text, int position, int length);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION *RL_TextReplace: char *text, const char *replace, const char *by  // Replace text string
//INLINE
//	return LIB::*TextReplace(char *text, const char *replace, const char *by);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION *RL_TextInsert: const char *text, const char *insert, int position  // Insert text in a position
//INLINE
//	return LIB::*TextInsert(const char *text, const char *insert, int position);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION char: const char **textList, int count, const char *delimiter  // Join text strings with delimiter
//INLINE
//	return LIB::char(const char **textList, int count, const char *delimiter);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION char: const char *text, char delimiter, int *count  // Split text into multiple strings
//INLINE
//	return LIB::char(const char *text, char delimiter, int *count);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION RL_TextAppend: char *text, const char *append, int *position  // Append text at specific position and move cursor!
//INLINE
//	LIB::TextAppend(char *text, const char *append, int *position);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION RL_TextFindIndex: const char *text, const char *find  // Find first text occurrence within a string
//INLINE
//	return LIB::TextFindIndex(const char *text, const char *find);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION char: const char *text  // Get upper case version of provided string
//INLINE
//	return LIB::char(const char *text);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION char: const char *text  // Get lower case version of provided string
//INLINE
//	return LIB::char(const char *text);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION char: const char *text  // Get Pascal case notation version of provided string
//INLINE
//	return LIB::char(const char *text);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION RL_TextToInteger: const char *text  // Get integer value from text
//INLINE
//	return LIB::TextToInteger(const char *text);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION *RL_TextToUtf8: int *codepoints, int length  // Encode text codepoint into utf8 text
//INLINE
//	return LIB::*TextToUtf8(int *codepoints, int length);
//ENDINLINE
//ENDFUNCTION
//
////------------------------------
//// UTF8 text strings management functions
////------------------------------
//FUNCTION *RL_GetCodepoints: const char *text, int *count  // Get all codepoints in a string, codepoints count returned by parameters
//INLINE
//	return LIB::*GetCodepoints(const char *text, int *count);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION RL_GetCodepointsCount: const char *text  // Get total number of characters
//INLINE
//	return LIB::GetCodepointsCount(const char *text);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION RL_GetNextCodepoint: const char *text, int *bytesProcessed  // Returns next codepoint in a UTF8 encoded string; 0x3f
//INLINE
//	return LIB::GetNextCodepoint(const char *text, int *bytesProcessed);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION char: int codepoint, int *byteLength  // Encode codepoint into utf8 text
//INLINE
//	return LIB::char(int codepoint, int *byteLength);
//ENDINLINE
//ENDFUNCTION


// TESTING STUFF!!!!!
SUB _TESTINGAREA:
ENDSUB


FUNCTION RL_GenTextureMipmaps: _font AS RL_Font
INLINE
	LIB::Font f;
	f = GLBasicFont_to_RaylibFont(_font);
	LIB::GenTextureMipmaps(&f.texture);
	_font = RaylibFont_to_GLBasicFont(&f);
ENDINLINE
ENDFUNCTION
