// --------------------------------- //
// Project: RayLib
// Start: Sunday, May 03, 2020
// IDE Version: 16.508

INLINE
}

namespace LIB{
	#include "raylib.h"
}

namespace __GLBASIC__{
ENDINLINE


//------------------------------
// Font loading/unloading functions
//------------------------------
//FUNCTION GetFontDefault: void  // Get the default Font
//INLINE
//	return LIB::GetFontDefault(void);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION LOADFONT: const char *fileName  // Load font from file into GPU memory 
//INLINE
//	return LIB::LoadFont(const char *fileName);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION LoadFontEx: const char *fileName, int fontSize, int *fontChars, int charsCount  // Load font from file with extended parameters
//INLINE
//	return LIB::LoadFontEx(const char *fileName, int fontSize, int *fontChars, int charsCount);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION LoadFontFromImage: Image image, Color KEY, int firstChar  // Load font from Image 
//INLINE
//	return LIB::LoadFontFromImage(Image image, Color key, int firstChar);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION *LoadFontData: const char *fileName, int fontSize, int *fontChars, int charsCount, int TYPE  // Load font data for further use
//INLINE
//	return LIB::*LoadFontData(const char *fileName, int fontSize, int *fontChars, int charsCount, int type);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION GenImageFontAtlas: const CharInfo *chars, Rectangle **recs, int charsCount, int fontSize, int padding, int packMethod  // Generate image font atlas using chars info
//INLINE
//	return LIB::GenImageFontAtlas(const CharInfo *chars, Rectangle **recs, int charsCount, int fontSize, int padding, int packMethod);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION UnloadFont: Font font  // Unload Font from GPU memory 
//INLINE
//	LIB::UnloadFont(Font font);
//ENDINLINE
//ENDFUNCTION
//
////------------------------------
//// Text drawing functions
////------------------------------
FUNCTION DrawFPS: posX, posY  // Shows current FPS
INLINE
	LIB::DrawFPS(posX, posY);
ENDINLINE
ENDFUNCTION

FUNCTION DrawText: text$, posX, posY, fontSize, color  // Draw text 
INLINE
	LIB::DrawText(text_Str.c_str(), posX, posY, fontSize, LIB::GetColor(color));
ENDINLINE
ENDFUNCTION

//FUNCTION DrawTextEx: Font font, const char *text, Vector2 position, float fontSize, float spacing, Color tint  // Draw text using font and additional parameters
//INLINE
//	LIB::DrawTextEx(Font font, const char *text, Vector2 position, float fontSize, float spacing, Color tint);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION DrawTextRec: Font font, const char *text, Rectangle rec, float fontSize, float spacing, bool wordWrap, Color tint  // Draw text using font inside rectangle limits
//INLINE
//	LIB::DrawTextRec(Font font, const char *text, Rectangle rec, float fontSize, float spacing, bool wordWrap, Color tint);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION DrawTextCodepoint: Font font, int codepoint, Vector2 position, float scale, Color tint  // Draw one character 
//INLINE
//	LIB::DrawTextCodepoint(Font font, int codepoint, Vector2 position, float scale, Color tint);
//ENDINLINE
//ENDFUNCTION
//
////------------------------------
//// Text misc. functions
////------------------------------
//FUNCTION MeasureText: const char *text, int fontSize  // Measure string width for default font
//INLINE
//	return LIB::MeasureText(const char *text, int fontSize);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION MeasureTextEx: Font font, const char *text, float fontSize, float spacing  // Measure string size for Font
//INLINE
//	return LIB::MeasureTextEx(Font font, const char *text, float fontSize, float spacing);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION GetGlyphIndex: Font font, int codepoint  // Get index position for a unicode character on font
//INLINE
//	return LIB::GetGlyphIndex(Font font, int codepoint);
//ENDINLINE
//ENDFUNCTION
//
////------------------------------
//// Text strings management functions (no utf8 strings, only byte chars)
////------------------------------
////------------------------------
//// NOTE: Some strings allocate memory internally for returned strings, just be careful!
////------------------------------
//FUNCTION TextCopy: char *dst, const char *src  // Copy one string to another, returns bytes copied
//INLINE
//	return LIB::TextCopy(char *dst, const char *src);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION TextIsEqual: const char *text1, const char *text2  // Check if two text string are equal
//INLINE
//	return LIB::TextIsEqual(const char *text1, const char *text2);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION int: const char *text  // Get text length, checks for '\0' ending
//INLINE
//	return LIB::int(const char *text);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION char: const char *text, ...  // Text formatting with variables 
//INLINE
//	return LIB::char(const char *text, ...);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION char: const char *text, int position, int length  // Get a piece of a text string
//INLINE
//	return LIB::char(const char *text, int position, int length);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION *TextReplace: char *text, const char *replace, const char *by  // Replace text string 
//INLINE
//	return LIB::*TextReplace(char *text, const char *replace, const char *by);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION *TextInsert: const char *text, const char *insert, int position  // Insert text in a position 
//INLINE
//	return LIB::*TextInsert(const char *text, const char *insert, int position);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION char: const char **textList, int count, const char *delimiter  // Join text strings with delimiter
//INLINE
//	return LIB::char(const char **textList, int count, const char *delimiter);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION char: const char *text, char delimiter, int *count  // Split text into multiple strings
//INLINE
//	return LIB::char(const char *text, char delimiter, int *count);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION TextAppend: char *text, const char *append, int *position  // Append text at specific position and move cursor!
//INLINE
//	LIB::TextAppend(char *text, const char *append, int *position);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION TextFindIndex: const char *text, const char *find  // Find first text occurrence within a string
//INLINE
//	return LIB::TextFindIndex(const char *text, const char *find);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION char: const char *text  // Get upper case version of provided string
//INLINE
//	return LIB::char(const char *text);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION char: const char *text  // Get lower case version of provided string
//INLINE
//	return LIB::char(const char *text);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION char: const char *text  // Get Pascal case notation version of provided string
//INLINE
//	return LIB::char(const char *text);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION TextToInteger: const char *text  // Get integer value from text 
//INLINE
//	return LIB::TextToInteger(const char *text);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION *TextToUtf8: int *codepoints, int length  // Encode text codepoint into utf8 text 
//INLINE
//	return LIB::*TextToUtf8(int *codepoints, int length);
//ENDINLINE
//ENDFUNCTION
//
////------------------------------
//// UTF8 text strings management functions                                                         
////------------------------------
//FUNCTION *GetCodepoints: const char *text, int *count  // Get all codepoints in a string, codepoints count returned by parameters
//INLINE
//	return LIB::*GetCodepoints(const char *text, int *count);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION GetCodepointsCount: const char *text  // Get total number of characters 
//INLINE
//	return LIB::GetCodepointsCount(const char *text);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION GetNextCodepoint: const char *text, int *bytesProcessed  // Returns next codepoint in a UTF8 encoded string; 0x3f
//INLINE
//	return LIB::GetNextCodepoint(const char *text, int *bytesProcessed);
//ENDINLINE
//ENDFUNCTION
//
//FUNCTION char: int codepoint, int *byteLength  // Encode codepoint into utf8 text 
//INLINE
//	return LIB::char(int codepoint, int *byteLength);
//ENDINLINE
//ENDFUNCTION

